<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PRISMS-PF: The Input File: parameters.in</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_pic.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PRISMS-PF
   &#160;<span id="projectnumber">v2.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('input_file.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Input File: parameters.in </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Most PRISMS-PF users will spend the majority of their time interacting with the input file, parameters.h. This file allows users to specify the computational domain, the mesh, the time step parameters, the boundary conditions, the output, and model constants (and more). This file is read as a text file, so modifications to it do not require recompilation of the application.</p>
<p>Here is an example of an input file from the <a href="https://github.com/prisms-center/phaseField/blob/master/applications/allenCahn/parameters.in">allenCahn application</a>: </p><div class="fragment"><div class="line"># Parameter list for the Allen-Cahn example application</div><div class="line"># Refer to the PRISMS-PF manual for use of these parameters in the source code.</div><div class="line"></div><div class="line"># =================================================================================</div><div class="line"># Set the number of dimensions (2 or 3 for a 2D or 3D calculation)</div><div class="line"># =================================================================================</div><div class="line">set Number of dimensions = 2</div><div class="line"></div><div class="line"># =================================================================================</div><div class="line"># Set the length of the domain in all three dimensions</div><div class="line"># (Domain size Z ignored in 2D)</div><div class="line"># =================================================================================</div><div class="line"># Each axes spans from zero to the specified length</div><div class="line">set Domain size X = 100</div><div class="line">set Domain size Y = 100</div><div class="line">set Domain size Z = 100</div><div class="line"></div><div class="line"># =================================================================================</div><div class="line"># Set the element parameters</div><div class="line"># =================================================================================</div><div class="line"># The number of elements in each direction is 2^(refineFactor) * subdivisions</div><div class="line"># Subdivisions Z ignored in 2D</div><div class="line"># For optimal performance, use refineFactor primarily to determine the element size</div><div class="line">set Subdivisions X = 1</div><div class="line">set Subdivisions Y = 1</div><div class="line">set Subdivisions Z = 1</div><div class="line"></div><div class="line">set Refine factor = 8</div><div class="line"></div><div class="line"># Set the polynomial degree of the element (allowed values: 1, 2, or 3)</div><div class="line">set Element degree = 1</div><div class="line"></div><div class="line"># =================================================================================</div><div class="line"># Set the time step parameters</div><div class="line"># =================================================================================</div><div class="line"># The size of the time step</div><div class="line">set Time step = 1.0e-2</div><div class="line"></div><div class="line"># The simulation ends when either the number of time steps is reached or the</div><div class="line"># simulation time is reached.</div><div class="line">set Number of time steps = 5000</div><div class="line"></div><div class="line"># =================================================================================</div><div class="line"># Set the output parameters</div><div class="line"># =================================================================================</div><div class="line"># Type of spacing between outputs (&quot;EQUAL_SPACING&quot;, &quot;LOG_SPACING&quot;, &quot;N_PER_DECADE&quot;,</div><div class="line"># or &quot;LIST&quot;)</div><div class="line">set Output condition = EQUAL_SPACING</div><div class="line"></div><div class="line"># Number of times the program outputs the fields (total number for &quot;EQUAL_SPACING&quot;</div><div class="line"># and &quot;LOG_SPACING&quot;, number per decade for &quot;N_PER_DECADE&quot;, ignored for &quot;LIST&quot;)</div><div class="line">set Number of outputs = 5</div><div class="line"></div><div class="line"># The number of time steps between updates being printed to the screen</div><div class="line">set Skip print steps = 1000</div><div class="line"></div><div class="line"># =================================================================================</div><div class="line"># Set the boundary conditions</div><div class="line"># =================================================================================</div><div class="line"># Set the boundary condition for each variable, where each variable is given by</div><div class="line"># its name, as defined in equations.h. The four boundary condition</div><div class="line"># types are NATURAL, DIRICHLET, NON_UNIFORM_DIRICHLET and PERIODIC. If all</div><div class="line"># of the boundaries have the same boundary condition, only one boundary condition</div><div class="line"># type needs to be given. If multiple boundary condition types are needed, give a</div><div class="line"># comma-separated list of the types. The order is the miniumum of x, maximum of x,</div><div class="line"># minimum of y, maximum of y, minimum of z, maximum of z (i.e left, right, bottom,</div><div class="line"># top in 2D and left, right, bottom, top, front, back in 3D). The value of a</div><div class="line"># Dirichlet BC is specfied in the following way -- DIRCHILET: val -- where &#39;val&#39; is</div><div class="line"># the desired value. If the boundary condition is NON_UNIFORM_DIRICHLET, the</div><div class="line"># boundary condition should be specified in the appropriate function in &#39;ICs_and_BCs.h&#39;.</div><div class="line"># Example 1: All periodic BCs for variable &#39;c&#39;</div><div class="line"># set Boundary condition for variable c = PERIODIC</div><div class="line"># Example 2: Zero-derivative BCs on the left and right, Dirichlet BCs with value</div><div class="line"># 1.5 on the top and bottom for variable &#39;n&#39; in 2D</div><div class="line"># set Boundary condition for variable n = NATURAL, NATURAL, DIRICHLET: 1.5, DIRICHLET: 1.5</div><div class="line"></div><div class="line">set Boundary condition for variable n = NATURAL</div><div class="line"></div><div class="line"># =================================================================================</div><div class="line"># Set the model constants</div><div class="line"># =================================================================================</div><div class="line"># Set the user-defined model constants, which must have a counter-part given in</div><div class="line"># customPDE.h. These are most often used in the residual equations in equations.h,</div><div class="line"># but may also be used for initial conditions and nucleation calculations. The type</div><div class="line"># options currently are DOUBLE, INT, BOOL, TENSOR, and [symmetry] ELASTIC CONSTANTS</div><div class="line"># where [symmetry] is ISOTROPIC, TRANSVERSE, ORTHOTROPIC, or ANISOTROPIC.</div><div class="line"></div><div class="line"># The mobility, MnV in equations.h</div><div class="line">set Model constant MnV = 1.0, DOUBLE</div><div class="line"></div><div class="line"># The gradient energy coefficient, KnV in equations.h</div><div class="line">set Model constant KnV = 2.0, DOUBLE</div></div><!-- fragment --><p>The syntax for setting each input parameter is: </p><div class="fragment"><div class="line">set [parameter name] = [parameter value]</div></div><!-- fragment --><p> The pound symbol (#) is used for comments, and any text after it is ignored by the file parser.</p>
<p>The following table lists all of the input parameters, separated into the same groupings in the input file above:</p>
<h3>Dimensionality</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number of dimensions  </td><td class="markdownTableBodyNone">2, 3  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">The number of dimensions for the simulation.   </td></tr>
</table>
<h3>Computational Domain</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Domain size X  </td><td class="markdownTableBodyNone">Any positive real number  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">The size of the domain in the x direction.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Domain size Y  </td><td class="markdownTableBodyNone">Any positive real number  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">The size of the domain in the y direction.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Domain size Z  </td><td class="markdownTableBodyNone">Any positive real number  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">The size of the domain in the z direction.   </td></tr>
</table>
<h3>Element Parameters</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Subdivisions X  </td><td class="markdownTableBodyNone">Any positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">The number of mesh subdivisions in the x direction to control the element aspect ratio. The mesh size is \(2^{(Refine Factor)} \times Subdivisions\) in each direction.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Subdivisions Y  </td><td class="markdownTableBodyNone">Any positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">The number of mesh subdivisions in the y direction to control the element aspect ratio.The mesh size is \(2^{(Refine Factor)} \times Subdivisions\) in each direction.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Subdivisions Z  </td><td class="markdownTableBodyNone">Any positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">The number of mesh subdivisions in the z direction to control the element aspect ratio. The mesh size is \(2^{(Refine Factor)} \times Subdivisions\) in each direction.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Refine factor  </td><td class="markdownTableBodyNone">Any non-negative integer  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">The number of initial refinements of the mesh. The mesh size is \(2^{(Refine Factor)} \times Subdivisions\) in each direction. While in principle the mesh could be entirely controlled by the number of subdivisons, computational performance is best when the majority of the refinement is done via the Refine factor.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Element degree  </td><td class="markdownTableBodyNone">1, 2, 3  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">The polynomial order of the elements. The spatial order of accuracy is one plus the degree.   </td></tr>
</table>
<h3>Mesh Adaptivity (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Mesh adaptivity  </td><td class="markdownTableBodyNone">Boolean  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Controls whether mesh adaptivity is enabled.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Max refinement level  </td><td class="markdownTableBodyNone">Any non-negative integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">-1  </td><td class="markdownTableBodyNone">The maximum number of local refinements during adaptive meshing. This parameter does not need to be specified if mesh adaptivity is disabled, but the default value will cause an error if mesh adaptivity is enabled.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Min refinement level  </td><td class="markdownTableBodyNone">Any non-negative integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">-1  </td><td class="markdownTableBodyNone">The minimum number of local refinements during adaptive meshing. This parameter does not need to be specified if mesh adaptivity is disabled, but the default value will cause an error if mesh adaptivity is enabled.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Refinement criteria fields  </td><td class="markdownTableBodyNone">Comma separated list of variable names  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">The indices of the variables that will determine the mesh refinement. The variable names are determined by the names given in equations.h.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Refinement window max  </td><td class="markdownTableBodyNone">Comma separated list of real numbers  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The mesh refines where the specified variables are between an upper and lower bound. This specifies the upper bound.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Refinement window min  </td><td class="markdownTableBodyNone">Comma separated list of real numbers  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The mesh refines where the specified variables are between an upper and lower bound. This specifies the lower bound.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Steps between remeshing operations  </td><td class="markdownTableBodyNone">Positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">The number of time steps between mesh refinement operations.   </td></tr>
</table>
<h3>Time Stepping</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Time step  </td><td class="markdownTableBodyNone">Any positive real number  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">The time step size for the simulation.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Number of time steps  </td><td class="markdownTableBodyNone">Any non-negative integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">-1  </td><td class="markdownTableBodyNone">The number of time steps until the simulation stops. Either this or the simulation end time must be specified. If both are specified, the simulation will end when the first condition is reached.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Simulation end time  </td><td class="markdownTableBodyNone">Any non-negative real number  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">-0.1  </td><td class="markdownTableBodyNone">The simulated time when until the simulation stops. Either this or the number of time steps must be specified. If both are specified, the simulation will end when the first condition is reached.   </td></tr>
</table>
<h3>Linear Solver Parameters (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Use absolute convergence tolerance  </td><td class="markdownTableBodyNone">Boolean  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Sets whether to use an absolute tolerance for the linear solver (versus a relative tolerance).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Solver tolerance value  </td><td class="markdownTableBodyNone">Any positive real number  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1e-3  </td><td class="markdownTableBodyNone">The tolerance for the linear solver. If an absolute tolerance is used, the iterative solver stops when the L2 norm of the residual drops below the tolerance. If a relative tolerance is used, the iterative solver stops when the L2 norm of the residual has dropped by a factor equal to the tolerance.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Maximum allowed solver iterations  </td><td class="markdownTableBodyNone">Any positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">10000  </td><td class="markdownTableBodyNone">The maximum number of iterations for the linear solver, if this number of iterations is reached, the solver stops regardless of the tolerance value.   </td></tr>
</table>
<h3>Output (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Output condition  </td><td class="markdownTableBodyNone">EQUAL_SPACING, LOG_SPACING, N_PER_DECADE, LIST  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">EQUAL_SPACING  </td><td class="markdownTableBodyNone">This sets the spacing between the times the simulation outputs the model variables. EQUAL_SPACING spaces them equally, LOG_SPACING spaces them \(10^{n/(outputs) \log(time steps)}\), N_PER_DECADE allows the user to set how many times the simulation outputs per power of ten iterations, and LIST outputs at a user-given list of time step numbers.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Number of outputs  </td><td class="markdownTableBodyNone">Any non-negative integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">The number of inputs if the output condition is EQUAL_SPACING. The number of outputs if the output condition is N_PER_DECADE. Ignored for the other output conditions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">List of time steps to output  </td><td class="markdownTableBodyNone">Comma-separated list of non-negative integers  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">The list of time steps to output, used for the LIST output condition and ignored for the others.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Output file name (base)  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">solution  </td><td class="markdownTableBodyNone">The name for the output file, before the time step and processor info are added.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Output file type  </td><td class="markdownTableBodyNone">vtu, vtk  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">vtu  </td><td class="markdownTableBodyNone">The output file type (currently limited to either vtu or vtk).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Output separate files per process  </td><td class="markdownTableBodyNone">Boolean  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Whether to output separate vtu files for each process in a parallel calculation (automatically set to true for vtk files). Separate files may decrease the time spent outputting results but may increase file tranfer times, as well as cluttering directories.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Skip print steps  </td><td class="markdownTableBodyNone">Any positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">The number of time steps between updates to the terminal window (1 is every time step).   </td></tr>
</table>
<h3>Checkpoints (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Load from a checkpoint  </td><td class="markdownTableBodyNone">Boolean  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Whether to start the simulation from the checkpoint of another simulation. See Note 2 below for the details of the checkpoint/restart system.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Checkpoint condition  </td><td class="markdownTableBodyNone">EQUAL_SPACING, LOG_SPACING, N_PER_DECADE, LIST  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">EQUAL_SPACING  </td><td class="markdownTableBodyNone">This sets the spacing between the times the simulation outputs the model variables. EQUAL_SPACING spaces them equally, LOG_SPACING spaces them \(10^{n/(outputs) \log(time steps)}\), N_PER_DECADE allows the user to set how many times the simulation outputs per power of ten iterations, and LIST outputs at a user-given list of time step numbers.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Number of checkpoints  </td><td class="markdownTableBodyNone">Any non-negative integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">The number of inputs if the output condition is EQUAL_SPACING. The number of outputs if the output condition is N_PER_DECADE. Ignored for the other output conditions.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">List of time steps to save checkpoints  </td><td class="markdownTableBodyNone">Comma-separated list of non-negative integers  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">The list of time steps to create checkpoints, used for the LIST output condition and ignored for the others.   </td></tr>
</table>
<h3>Boundary Conditions</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Boundary condition for variable [variable name]  </td><td class="markdownTableBodyNone">NATURAL, DIRICHLET, NON_UNIFORM_DIRICHLET, PERIODIC  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">Sets the boundary condition for each scalar variable, using the variable name from equations.h. One line is required for each scalar variable. See Note 1 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Boundary condition for variable [variable name], component [direction]  </td><td class="markdownTableBodyNone">NATURAL, DIRICHLET, NON_UNIFORM_DIRICHLET, PERIODIC  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">n/a  </td><td class="markdownTableBodyNone">Sets the boundary condition for each vector variable, using the variable name from equations.h. One line is required for each vector variable. See Note 1 below for details.   </td></tr>
</table>
<h3>Loading Initial Conditions from File (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Load initial conditions  </td><td class="markdownTableBodyNone">Comma-separated list of booleans  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">One true/false flag for each variable for whether the initial condition should be loaded from a vtk file. Currently, only scalar fields can be read in. See Note 3 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Load parallel file  </td><td class="markdownTableBodyNone">Comma-separated list of booleans  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">One true/false flag for each variable for whether each processor should read the initial conditions from a seperate file. See Note 3 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">File names  </td><td class="markdownTableBodyNone">Comma-separated list of strings  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The name of the vtk file to be read for each variable, ignored for variables where the initial conditions isn't read in from a file. Often, all of the variables will read from the same vtk file. See Note 3 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Variable names in the files  </td><td class="markdownTableBodyNone">Comma-separated list of strings  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">What each variable is named in the file being loaded. See Note 3 below for details.   </td></tr>
</table>
<h3>Shared Nucleation Parameters (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Time steps between nucleation attempts  </td><td class="markdownTableBodyNone">Any positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">The number of time steps between nucleation attempts. This parameter is shared among all nucleating variables. See Note 4 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Minimum allowed distance between nuclei  </td><td class="markdownTableBodyNone">Any non-negative real number  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">2 \(\times\) the largest nucleus semiaxis  </td><td class="markdownTableBodyNone">The minimum allowed distance between nuclei centers during a single nucleation attempt. This parameter is shared among all nucleating variables. See Note 4 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Order parameter cutoff value  </td><td class="markdownTableBodyNone">Any non-negative real number  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">0.01  </td><td class="markdownTableBodyNone">The minimum allowed value of the sum of all nucleating variable fields where nucleation is allowed to occur. Implemented to prevent nucleation inside existing particles. This parameter is shared among all nucleating variables. See Note 4 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Time steps between nucleation attempts  </td><td class="markdownTableBodyNone">Any positive integer  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">100  </td><td class="markdownTableBodyNone">The number of time steps between nucleation attempts. This parameter is shared among all nucleating variables. See Note 4 below for details.   </td></tr>
</table>
<h3>Nucleation Parameters for Each Nucleating Variable (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Nucleus semiaxes (x, y ,z)  </td><td class="markdownTableBodyNone">Three positive real numbers  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The semiaxes of the ellipsoidal nuclei to be seeded. See Note 4 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Nucleus rotation in degrees (x, y, z)  </td><td class="markdownTableBodyNone">Three real numbers  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The rotation of the nuclei placed with the explicit nucleation algorithm. The rotations are given with respect to the normal direction using intrinsic Tait-Bryan angles. Positive rotations correspond to a counter-clockwise rotation when looking along the positive axis of interest. All three angles must be specified regardless of problem dimension.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Freeze zone semiaxes (x, y ,z)  </td><td class="markdownTableBodyNone">Three positive real numbers  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">The semiaxes for the ellipsoidal region where the nucleus is frozen after seeding. See Note 4 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Freeze time following nucleation  </td><td class="markdownTableBodyNone">Any non-negative real number  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">The amount of time the nucleus is frozen after seeding. See Note 4 below for details.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Nucleation-free border thickness  </td><td class="markdownTableBodyNone">Any non-negative real number  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">The size of the buffer region where nucleation is not allowed unless the boundary conditions are periodic. See Note 4 below for details.   </td></tr>
</table>
<h3>Model constants (Optional)</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Model constant [constant name]  </td><td class="markdownTableBodyNone">value followed by a comma then a type  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Sets the value of a constant defined for that particular application. The allowed types are DOUBLE, INT, BOOL, TENSOR, and [symmetry] ELASTIC CONSTANTS where [symmetry] is ISOTROPIC, TRANSVERSE, ORTHOTROPIC, or ANISOTROPIC. See Note 5 below for details.   </td></tr>
</table>
<h2>Note 1: Boundary Conditions</h2>
<p>The boundary condition must be set for each variable, where each variable is given by its name, as defined in equations.h. The four boundary condition types are NATURAL, DIRICHLET, NON_UNIFORM_DIRICHLET and PERIODIC. If all of the boundaries have the same boundary condition, only one boundary condition type needs to be given. If multiple boundary condition types are needed, give a comma-separated list of the types. The order is the miniumum of x, maximum of x, minimum of y, maximum of y, minimum of z, maximum of z (i.e left, right, bottom, top in 2D and left, right, bottom, top, front, back in 3D). The value of a Dirichlet BC is specfied in the following way &ndash; DIRCHILET: val &ndash; where 'val' is the desired value. If the boundary condition is NON_UNIFORM_DIRICHLET, the boundary condition should be specified in the appropriate function in 'ICs_and_BCs.cc'. For vector variables, one boundary condition should be specified for each component.</p>
<p>Example 1: All periodic BCs for variable 'c' </p><div class="fragment"><div class="line">set Boundary condition for variable c = PERIODIC</div></div><!-- fragment --><p>Example 2: Zero-derivative BCs on the left and right, Dirichlet BCs with value 1.5 on the top and bottom for variable 'n' in 2D </p><div class="fragment"><div class="line">set Boundary condition for variable n = NATURAL, NATURAL, DIRICHLET: 1.5,</div><div class="line"> DIRICHLET: 1.5</div></div><!-- fragment --><p>Example 3: All periodic BCs for the y component of the vector variable 'u' </p><div class="fragment"><div class="line">set Boundary condition for variable u, component y = PERIODIC</div></div><!-- fragment --><h2>Note 2: Checkpoint/Restart</h2>
<p>The checkpoint/restart simulation allows one to continue from a previous simulation by loading the mesh and variable values from that previous simulation. One use of this system is to continue a simulation that stopped part of the way through, due to a hardware failure, running out of the allotted time on a cluster, etc. A second use is to use one simulation as the initial condition for another. Note that the simulated time carries over from the checkpoint. Thus if one ran a simulation to completion but wanted to see further evolution, one could load from the checkpoint created at the end of that simulation, but the desired number of time steps or simulation end time would have to be increased. Currently, the checkpoint system always read from files named ''restart.mesh'', ''restart.mesh.info'', and ''restart.time.info''. When a checkpoint is created, the previous checkpoint files have ''.old'' appended to their file names. To load from these older checkpoint files, the newer ones should be deleted (or moved) and the ''.old'' should be deleted from the names of the older files. An example of using the checkpoint/restart system can be seen in the 'dendriticSolidification' application.</p>
<h3>Note 3: Loading Initial Conditions from File</h3>
<p>Currently, initial conditions can only be read from vtk files (<em>not</em> vtu files). Some variables can have initial conditions read from file and others can be specified in ICs_and_BCs.cc in the same application. For each variable, the user must set whether the file(s) to be read are in serial format, where all processors read from the same file, or parallel format, where all processors read from different files. If parallel format is selected, the desired domain decomposition must between the files and the simulation to be run. For non-adaptive meshes this will be true if the same number of cores is the same between the simulation that generated the vtk files and the simulation reading the vtk files. For adaptive meshes, obtaining the same domain decomposition may be difficult and merging parallel vtk files into a single file is likely the best approach. This process is planned to be cleaner in future versions of PRISMS-PF. An example of loading initial conditions from file can be seen in the 'allenCahn' application, using the 'parameters_pfield.in' input file.</p>
<h3>Note 4: Nucleation</h3>
<p>PRISMS-PF includes the capability for explicitly placing nuclei over the course of a simulation using an approach similar to the one described in the following publication:</p>
<p>Jokisaari, Permann, and Thornton, A nucleation algorithm for the coupled conserved-nonconserved phase field model, {Computational Materials Science}, 112, (2016).</p>
<p>A nucleus of an non-conserved order parameter is placed within the computational domain determined by a probability given by the 'getNucleationProbability' function in the '<a class="el" href="nucleation_8cc.html">nucleation.cc</a>' file. The variables that are allowed to nucleate are specified in the 'loadVariableAttributes' function in the 'equations.cc' file, as are the variable values needed to calculate the nucleation probability. The determination of when and where a nucleus should be seeded is determined in the core PRISMS-PF library, but the actual placement of the nucleus by modifying one of the model fields is expected to be performed in the 'explicitEquationRHS' function in the 'equations.cc' file. The placement of the nucleus is aided by the 'weightedDistanceFromNucleusCenter' function in the core library. The mobility for the nucleated field should be set to zero in the region surrounding the nucleus (the ''freeze zone'') for a specified amount of time (the ''freeze time''). Examples of nucleating particles can be found in the 'nucleationModel' and 'nucleationModel_preferential' applications.</p>
<p>Currently, the nucleation parameters are one of the few places where the subsection' command is used in the input file. This command is used to set nucleation parameters separately for each nucleating variable. Each subsection is opened by ''subsection Nucleation parameters:'' followed by the variable name as set in 'equations.cc'. The end of each subsection block is concluded with the 'end' command. For example, if there are two nucleating order parameters <b>n1</b> and <b>n2</b>, the nucleation parameters section could look as follows: </p><div class="fragment"><div class="line"># =================================================================================</div><div class="line"># Set the nucleation parameters</div><div class="line"># =================================================================================</div><div class="line"></div><div class="line">set Time steps between nucleation attempts = 30</div><div class="line">set Minimum allowed distance between nuclei = 50.0</div><div class="line">set Order parameter cutoff value = 0.01</div><div class="line"></div><div class="line">subsection Nucleation parameters: n1</div><div class="line">    set Nucleus semiaxes (x, y, z) = 10, 5, 5</div><div class="line">    set Nucleus rotation in degrees (x, y, z) = 0, 0, 60</div><div class="line">    set Freeze zone semiaxes (x, y, z) = 15, 7.5, 7.5</div><div class="line">    set Freeze time following nucleation = 20</div><div class="line">    set Nucleation-free border thickness = 15</div><div class="line">end</div><div class="line"></div><div class="line">subsection Nucleation parameters: n2</div><div class="line">    set Nucleus semiaxes (x, y, z) = 20, 10, 10</div><div class="line">    set Nucleus rotation in degrees (x, y, z) = 0, 0, 0</div><div class="line">    set Freeze zone semiaxes (x, y, z) = 30, 15, 15</div><div class="line">    set Freeze time following nucleation = 40</div><div class="line">    set Nucleation-free border thickness = 30</div><div class="line">end</div></div><!-- fragment --><p> The first three lines set the shared nucleation parameters. Next comes the subsection block for the variable <b>n1</b> and the subsection block for the variable <b>n2</b>.</p>
<h2>Note 5: Model constants</h2>
<p>Each application specifies its own set of model constants. These are most often used in the residual equations in the 'equations.cc' file, although they may also be used to specify initial conditions, non-uniform Dirichlet boundary conditions, nucleation probabilties, etc. Currently, five types of model constants are accepted: DOUBLE, INT, BOOL, TENSOR, and ELASTIC CONSTANTS. The use of these different types is as follows:</p>
<ul>
<li>DOUBLE: For individual real numbers</li>
<li>INT: For individual integers</li>
<li>BOOL: For individual booleans (true/false)</li>
<li>TENSOR: For either rank 1 tensors (i.e. vectors) or rank 2 tensors (i.e. matrices) with a size of the number of dimensions. These are assumed to be real numbers. Each row should be given by a comma-separated list in parentheses. For example, a 3D vector would be given as <code>(2.5, 1.2, 0.1)</code> and a 2D matrix would be given as: <code>((4.1, 2.0),(1.6, 5.2))</code>.</li>
<li>{[symmetry]} ELASTIC CONSTANTS: For sets of elastic constants, given as a vector. The symmetry options are ISOTROPIC, TRANSVERSE, ORTHOTROPIC, or ANISOTROPIC. The number of entries for the different symmetries are given below. PRISMS-PF converts these sets of elastic constants into a stiffness matrix.</li>
</ul>
<p>The number and order of the entries for the elastic constants are (where \(C_{ij}\) are entries in the stiffness matrix):</p>
<ul>
<li>ISOTROPIC (2D/3D): 2 constants (Young's Modulus, Poisson's Ratio)</li>
<li>TRANSVERSE (3D): 5 constants ( \(C_{11}\), \(C_{33}\), \(C_{44}\), \(C_{12}\), \(C_{13}\))</li>
<li>ORTHOTROPIC (3D): 9 constants ( \(C_{11}\), \(C_{22}\), \(C_{33}\), \(C_{44}\), \(C_{55}\), \(C_{66}\), \(C_{12}\), \(C_{13}\), \(C_{23}\))</li>
<li>ANISOTROPIC (2D/3D): 21 constants ( \(C_{11}\), \(C_{22}\), \(C_{33}\), \(C_{44}\), \(C_{55}\), \(C_{66}\), \(C_{12}\), \(C_{13}\), \(C_{14}\), \(C_{15}\), \(C_{16}\), \(C_{23}\), \(C_{24}\), \(C_{25}\), \(C_{26}\), \(C_{34}\), \(C_{35}\), \(C_{36}\), \(C_{45}\), \(C_{46}\), \(C_{56}\))</li>
</ul>
<p>Each model constant in &lsquo;parameters.in&rsquo; must have a counterpart in the appropriate section of the &lsquo;customPDE.h&rsquo; file. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>

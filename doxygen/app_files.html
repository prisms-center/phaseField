<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PRISMS-PF: Other App Files</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML#http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_navtree.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_pic.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PRISMS-PF
   &#160;<span id="projectnumber">v2.3</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)"
               onblur="searchBox.OnSearchFieldFocus(false)"
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;"
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('app_files.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Other App Files </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section details the files that define each application. The norm is that substantial modifications to these files consistute a new application (in contrast to simply making changes to the input file ('parameters.prm'). Modifying these files may require some knowledge of C++.</p>
<p>A very brief description of the purpose of each of these files is below, an in-depth discussion can be found in the following subsections:</p><ul>
<li>equations.cc: Specifies the attributes of the model variables and the model's residual equations</li>
<li>ICs_and_BCs.cc: Specifies the initial conditions for each variable (unless the initial condition is read from file) and non-uniform Dirichlet boundary conditions, if applicable.</li>
<li>postprocess.cc: Specifies variable other than the primary model variables to output, as well as the expressions to derive these variables.</li>
<li><a class="el" href="nucleation_8cc.html">nucleation.cc</a>: Contains the function that determines the probability density of nucleation.</li>
<li>customPDE.h: Contains the prototypes of the functions for the application, also contains declarations of the model constants given in the input file.</li>
<li><a class="el" href="main_8cc.html">main.cc</a>: Main C++ function that controls the flow of the simulation. Identical for all the example applications and it is unlikely that users will need to modify it.</li>
</ul>
<p>In all of these files, the user can access user inputs from parameters.prm via the userInputs object (e.g. the domain size, the time step size). See the documentation entry for <a class="el" href="classuser_input_parameters.html">userInputParameters</a> for a list of variable names inside ''userInputs''.</p>
<h2>equations.cc</h2>
<p>The file ''equations.cc'' contains a list of the variables in the model equations and their attributes as well as the residuals for the model equations. The file contains four functions: loadVariableAttributes, explicitEquationRHS, nonExplicitEquationRHS, and equationLHS.</p>
<p>To modify the functions in this file, one needs to be familiar with the weak form of the governing equations. In PRISMS-PF, the governing equations are expressed in two terms. The first is the part of the integrand that is multiplied by the test function (marked by 'eq' with the subscript of the variable in the example below). The second is the part of the integrand that multiplied by the gradient of the test function (marked by 'eqx' with the subscript of the variable in the example below). For the coupled Cahn-Hilliard/Allen-Cahn system, the governing equations are</p>
<p class="formulaDsp">
\[ \int_{\Omega} w \eta^{n+1} ~dV =\int_{\Omega} w \left( \underbrace{\eta^{n} - \Delta t M_{\eta}~ ((f_{\beta,c}^n-f_{\alpha,c}^n)H_{,\eta}^n)}_{eq_{\eta}} \right)+ \nabla w \cdot \underbrace{(- \Delta t M_{\eta}\kappa) \nabla \eta^{n}}_{eqx_{\eta}} ~dV \]
</p>
<p>and</p>
<p class="formulaDsp">
\[ ]$\int_{\Omega} w c^{n+1} ~dV = \int_{\Omega} w \underbrace{c^{n}}_{eq_c} + \nabla w \underbrace{(-\Delta t M_{c})~ [~(f_{\alpha,cc}^n(1-H^{n+1})+f_{\beta,cc}^n H^{n+1}) \nabla c + ~((f_{\beta,c}^n-f_{\alpha,c}^n)H^{n+1}_{,\eta} \nabla \eta) ] }_{eqx_{c}} ~dV \]
</p>
<p>for the Allen-Cahn and Cahn-Hilliard equation, respectively. Each of the terms in the governing equation is marked with an underbrace. The terms multiplied by the test function are referred to as the value terms and the terms multiplied by the gradient of the test function are referred to as the gradient terms.</p>
<h3>loadVariableAttributes</h3>
<p>Here is the loadVariableAttributes function for the coupled Allen-Cahn/Cahn-Hilliard example application: </p><div class="fragment"><div class="line">void variableAttributeLoader::loadVariableAttributes(){</div><div class="line">    // Variable 0</div><div class="line">    set_variable_name               (0,&quot;c&quot;);</div><div class="line">    set_variable_type               (0,SCALAR);</div><div class="line">    set_variable_equation_type      (0,EXPLICIT_TIME_DEPENDENT);</div><div class="line"></div><div class="line">    set_dependencies_value_term_RHS(0, &quot;c&quot;);</div><div class="line">    set_dependencies_gradient_term_RHS(0, &quot;n,grad(c)&quot;);</div><div class="line"></div><div class="line">    // Variable 1</div><div class="line">    set_variable_name               (1,&quot;n&quot;);</div><div class="line">    set_variable_type               (1,SCALAR);</div><div class="line">    set_variable_equation_type      (1,EXPLICIT_TIME_DEPENDENT);</div><div class="line"></div><div class="line">    set_dependencies_value_term_RHS(1, &quot;c,n&quot;);</div><div class="line">    set_dependencies_gradient_term_RHS(1, &quot;grad(n)&quot;);</div><div class="line">}</div></div><!-- fragment --><p>This function specifies the model variables and their attributes. In this case, the two model variables are the concentration, <b>c</b>, and the order parameter, <b>n</b>. Here, <b>c</b> is listed as the zeroth variable and <b>n</b> is listed as the first. For each variable, a series of attributes are set using a series of C++ function calls. The following table lists the functions and a description of the attributes they set:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_variable_name  </td><td class="markdownTableBodyNone">[String]  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">var  </td><td class="markdownTableBodyNone">Sets the name of the variable. This name is used in 'parameters.prm' as well as during output.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">set_variable_type  </td><td class="markdownTableBodyNone">SCALAR, VECTOR  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">SCALAR  </td><td class="markdownTableBodyNone">Sets whether the variable is a scalar or a vector.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_variable_equation_type  </td><td class="markdownTableBodyNone">EXPLICIT_TIME_DEPENDENT, AUXILIARY, TIME_INDEPENDENT  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">EXPLICIT_TIME_DEPENDENT  </td><td class="markdownTableBodyNone">Sets whether the governing equation for the variable is a time-dependent PDE (EXPLICIT_TIME_DEPENDENT), a time-independent PDE that does not require a linear solve (AUXILIARY) or a time independent PDE that does require a (non)linear solve (TIME_INDEPENDENT).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">set_dependencies_value_term_RHS  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">N/A  </td><td class="markdownTableBodyNone">Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by <code>grad</code> and then the variable name in parentheses. Second derivatives are referenced by <code>hess</code> and then the variable name in parentheses.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_dependencies_gradient_term_RHS  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone">N/A  </td><td class="markdownTableBodyNone">Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by <code>grad</code> and then the variable name in parentheses. Second derivatives are referenced by <code>hess</code> and then the variable name in parentheses.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">set_dependencies_value_term_LHS  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">[empty]  </td><td class="markdownTableBodyNone">Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by <code>grad</code> and then the variable name in parentheses. Second derivatives are referenced by <code>hess</code> and then the variable name in parentheses. (Only needed for TIME_INDEPENDENT equations.)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_dependencies_gradient_term_LHS  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">[empty]  </td><td class="markdownTableBodyNone">Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by <code>grad</code> and then the variable name in parentheses. Second derivatives are referenced by <code>hess</code> and then the variable name in parentheses. (Only needed for TIME_INDEPENDENT equations.)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">set_allowed_to_nucleate  </td><td class="markdownTableBodyNone">Boolean  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Sets whether the nucleation algorithms should be activated for this variable. (Only needed when nucleation is desired).   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_need_value_nucleation  </td><td class="markdownTableBodyNone">Boolean  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Sets whether the value of the variable is needed to calculate the nucleation probability in the '<a class="el" href="nucleation_8cc.html">nucleation.cc</a>' file. (Only needed when nucleation is desired).   </td></tr>
</table>
<p>Some of these function calls are not present in the 'equations.cc' file for the coupledCahnHilliardAllenCahn application. Use of the LHS function calls can be found in the preciptiateEvolution application (among others) and use the nucleation function calls can be found the nucleationModel and nucleationModel_preferential applications.</p>
<h3>explicitEquationRHS</h3>
<p>The explicitEquationRHS function is where the terms in the RHS of the governing equations for EXPLICIT_TIME_DEPENDENT equations are entered. The terms in the RHS of other equations are entered into the nonExplicitEquationRHS function. Here is the explicitEquationRHS function from the coupled Allen-Cahn/Cahn-Hilliard example application: </p><div class="fragment"><div class="line">template &lt;int dim, int degree&gt;</div><div class="line">void customPDE&lt;dim,degree&gt;::explicitEquationRHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line">                 dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"></div><div class="line">// --- Getting the values and derivatives of the model variables ---</div><div class="line"></div><div class="line">//c</div><div class="line">scalarvalueType c = variable_list.get_scalar_value(0);</div><div class="line">scalargradType cx = variable_list.get_scalar_gradient(0);</div><div class="line"></div><div class="line">//n</div><div class="line">scalarvalueType n = variable_list.get_scalar_value(1);</div><div class="line">scalargradType nx = variable_list.get_scalar_gradient(1);</div><div class="line"></div><div class="line">// --- Setting the expressions for the terms in the governing equations ---</div><div class="line"></div><div class="line">// Free energy for each phase and their first and second derivatives</div><div class="line">scalarvalueType fa = (-1.6704-4.776*c+5.1622*c*c-2.7375*c*c*c+1.3687*c*c*c*c);</div><div class="line">scalarvalueType fac = (-4.776 + 10.3244*c - 8.2125*c*c + 5.4748*c*c*c);</div><div class="line">scalarvalueType facc = (10.3244-16.425*c+16.4244*c*c);</div><div class="line">scalarvalueType fb = (5.0*c*c-5.9746*c-1.5924);</div><div class="line">scalarvalueType fbc = (10.0*c-5.9746);</div><div class="line">scalarvalueType fbcc = constV(10.0);</div><div class="line"></div><div class="line">// Interpolation function and its derivative</div><div class="line">scalarvalueType h = (10.0*n*n*n-15.0*n*n*n*n+6.0*n*n*n*n*n);</div><div class="line">scalarvalueType hn = (30.0*n*n-60.0*n*n*n+30.0*n*n*n*n);</div><div class="line"></div><div class="line">// Residual equations</div><div class="line">scalargradType mux = ( cx*((1.0-h)*facc+h*fbcc) + nx*((fbc-fac)*hn) );</div><div class="line">scalarvalueType eq_c = c;</div><div class="line">scalargradType eqx_c = (constV(-Mc*userInputs.dtValue)*mux);</div><div class="line">scalarvalueType eq_n = (n-constV(userInputs.dtValue*Mn)*(fb-fa)*hn);</div><div class="line">scalargradType eqx_n = (constV(-userInputs.dtValue*Kn*Mn)*nx);</div><div class="line"></div><div class="line"></div><div class="line">// --- Submitting the terms for the governing equations ---</div><div class="line"></div><div class="line">// Terms for the equation to evolve the concentration</div><div class="line">variable_list.set_scalar_value_term_RHS(0,eq_c);</div><div class="line">variable_list.set_scalar_gradient_term_RHS(0,eqx_c);</div><div class="line"></div><div class="line">// Terms for the equation to evolve the order parameter</div><div class="line">variable_list.set_scalar_value_term_RHS(1,eq_n);</div><div class="line">variable_list.set_scalar_gradient_term_RHS(1,eqx_n);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>In this function the equation terms at a particular quadrature point are calculated. The inputs to this function are a list of the model variable values and derivatives, variable_list and a point giving access to (x,y,z) coordinates, q_point_loc. The equation terms are added to variable_list as the output. The first few lines of the function set more convenient names for the variables and their derivatives. By convention, the value of the variable is denoted by the variable name (c for the concentration and n for the structural order parameter in this case), the list of first derivatives is denoted by the variable name followed by an ''x'', and second derivatives are denoted by the variable name followed by ''xx''. Each variable in variable can be accessed by the index it was given in loadVariableAttributes. The variable value and the derivatives can be accessed through the get_scalar_value, get_scalar_gradient, and get_scalar_hessian object members for scalar variables and the get_vector_value, get_vector_gradient, and get_vector_hessian functions. The data type for the value of a scalar variable is scalarvalueType (a scalar), the data type for the first derivatives of a scalar variable is scalargradType (a vector with a length equal to the number of dimensions), and the data type for the second derivatives of a scalar variable is scalarhessType (a matrix with a size equal to the number of dimensions by the number of dimensions). For vector variables, the data types are vectorvalueType (a vector with length equal to the number of dimensions), vectorgradType (a matrix with a size equal to the number of dimensions by the number of dimensions), and vectorgradType (a rank-three tensor with a size in each direction equal to the number of dimensions).</p>
<p>After the nicknames for the field variables are set, the equation terms are calculated (including some intermediate variables, such as the free energies and the interpolation functions in the example above). These use the same six data types discussed in the preceding paragraph. The model variables given in 'parameters.prm' can be used to define the residual terms.</p>
<p>Finally, the terms for the governing equations are submitted to variable_list, using the functions set_scalar_value_term_RHS, set_scalar_gradient_term_RHS, set_vector_value_term_RHS, and set_vector_gradient_term_RHS, once again referring the variables by their index.</p>
<p>The nickname step can be skipped, if desired, although the code is generally more readable with nicknames (and the performance is in some cases better using the nicknames). An example without nicknames for the fields can be found in the grainGrowth application, where loops over the ten variables are easier to construct when not declaring all of the variables at once. One word of caution, though: calling set_scalar_value_term_RHS and set_scalar_gradient_term_RHS overwrites the value and gradient of the variable, respectively (and same for the variants for vectors). Thus, either the equation terms need to be cached and then set after all the equation terms have been calculated (as is done in the grainGrowth application) or the values and gradients need to be cached before setting the equation terms (as is done with the standard nicknaming approach).</p>
<h4>A note on types</h4>
<p>The deal.II library uses a data structure called a VectorizedArray to store the variable values and their derivatives. This data structured in optimized for modern vectorized processors, giving a substantial speedup in some cases. However, this data structure can complicate things slightly. One complicating factor is that VectorizedArrays can't always be added, subtracted, multiplied, or divided with more standard data types like doubles. For this reason, you will see the ''<a class="el" href="matrix_free_p_d_e_8h.html#af4deabb57f7353cd1981dbbb926455cd">constV(argument)</a>'' function scattered throughout the code. This function turns a non-VectorizedArray into a VectorizedArray. To be safe, you can always encase non-VectorizedArrays with ''<a class="el" href="matrix_free_p_d_e_8h.html#af4deabb57f7353cd1981dbbb926455cd">constV()</a>'' when they share an operation with a VectorizedArray. A second complication is that not all of the standard mathematical operations are available for VectorizedArrays. The basic trigonometric functions are available, as are exponentials and square roots. However, hyperbolic tangents are not. If needed, they must be constructed from exponents (or by iterating through the VectorizedArray, see below). A third complication is that conditional statements involving VectorizedArrays are not allowed. To perform a conditional statement, you must iterate through the VectorizedArray. To do still, construct a for loop where the maximum index is [variable name].n_array_elements. For examples of this, refer to the postprocessing file for the grainGrowth app or the seedNucleus function in 'equations.cc' in the nucleationModel app. For more details on the deal.II implementation of VectorizedArrays (including a list of mathematical operations that are allowed), please visit <a href="https://www.dealii.org/8.4.0/doxygen/deal.II/classVectorizedArray.html">the relevant deal.II documentation page</a>.</p>
<h3>nonExplicitEquationRHS</h3>
<p>The 'nonExplicitEquationRHS' function is where the terms in the RHS of the governing equations for AUXILIARY and TIME_INDEPENDENT equations are entered. The terms in the RHS of EXPLICIT_TIME_DEPENDENT equations are entered into the explicitEquationRHS function. The structure and use is otherwise identical to explicitEquationRHS. Examples of apps where this function is used include cahnHilliard (for an AUXILIARY equation) and MgNd_precipitate_single_Bppp (for AUXILIARY and TIME_INDEPENDENT equations).</p>
<h3>equationLHS</h3>
<p>In the coupledCahnHilliardAllenCahn app, the equationLHS function is empty because it is only needed for TIME_INDEPENDENT PDEs (or more specifically, when a non-trivial matrix inversion needs to be performed). Here we go through the equationLHS function from the precipitateEvolution application, where the equation for mechanical equilibrium is TIME_INDEPENDENT.</p>
<p>From the formulation file in the precipitateEvolution application, the governing equation for the mechanical displacement is: </p><p class="formulaDsp">
\[ R(u) = \int_{\Omega} \nabla w : C(\eta_1, \eta_2, \eta_3) : \left( \epsilon - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = 0 \]
</p>
<p>In PRISMS-PF, matrix inversion problems are always written as Newton's method iterations. For linear equations, like the one above, the solution is reached in a single Newton step. The reason for this approach is two-fold. First, it provides an identical user interface for linear and nonlinear problems. Second, it enables the efficient handling of constraints for when inhomogeneous Dirichlet boundary conditions are used.</p>
<p>To write the above equations in terms of a Newton iteration, the solution, \(u\), can be written as the sum of an initial guess, \(u_0\), and an update, \(\Delta u\):</p>
<p class="formulaDsp">
\[ R(u) = R(u_0 + \Delta u) = R(u_0) + \int_{\Omega} \left. \frac{\delta R(u)}{\delta u}\right|_{u=u_0} \Delta u ~dV = 0 \]
</p>
<p>In this case, the equation is linear and the variation derivative is trivial:</p>
<p class="formulaDsp">
\[ R(u_0 + \Delta u) = \int_{\Omega} \nabla w : C(\eta_1, \eta_2, \eta_3) : \left( \epsilon(u_0 + \Delta u) - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = \int_{\Omega} \nabla w : C(\eta_1, \eta_2, \eta_3) : \left( \epsilon(u_0) + \epsilon(\Delta u) - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = 0 \]
</p>
<p>Rearranging yields:</p>
<p class="formulaDsp">
\[ \int_{\Omega} \nabla w : \underbrace{C : \nabla (\epsilon(\Delta u))}_{eqx_{u}^{LHS}} dV = -\int_{\Omega} \nabla w : \underbrace{C :(\epsilon(u_0)-\epsilon^0)}_{eqx_{u}^{RHS}} ~dV \]
</p>
<p>The above values of \(eqx_{u}^{LHS}\) and \(eqx_{u}^{RHS}\) are used to define the residuals in the equations.cc file. A similar process can be undertaken for other TIME_INDEPENDENT problems.</p>
<p>Here is the 'equationLHS' function from the precipitateEvolution example application: </p><div class="fragment"><div class="line">template &lt;int dim, int degree&gt;</div><div class="line">void customPDE&lt;dim,degree&gt;::equationLHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line">        dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"></div><div class="line">// --- Getting the values and derivatives of the model variables ---</div><div class="line"></div><div class="line">//n1</div><div class="line">scalarvalueType n1 = variable_list.get_scalar_value(1);</div><div class="line"></div><div class="line">//n2</div><div class="line">scalarvalueType n2 = variable_list.get_scalar_value(2);</div><div class="line"></div><div class="line">//n3</div><div class="line">scalarvalueType n3 = variable_list.get_scalar_value(3);</div><div class="line"></div><div class="line">//u</div><div class="line">vectorgradType Dux = variable_list.get_change_in_vector_gradient(4);</div><div class="line"></div><div class="line"></div><div class="line">// --- Setting the expressions for the terms in the governing equations ---</div><div class="line"></div><div class="line">vectorgradType eqx_Du;</div><div class="line"></div><div class="line">// Interpolation functions</div><div class="line"></div><div class="line">scalarvalueType h1V = (10.0*n1*n1*n1-15.0*n1*n1*n1*n1+6.0*n1*n1*n1*n1*n1);</div><div class="line">scalarvalueType h2V = (10.0*n2*n2*n2-15.0*n2*n2*n2*n2+6.0*n2*n2*n2*n2*n2);</div><div class="line">scalarvalueType h3V = (10.0*n3*n3*n3-15.0*n3*n3*n3*n3+6.0*n3*n3*n3*n3*n3);</div><div class="line"></div><div class="line">// Take advantage of E being simply 0.5*(ux + transpose(ux)) and use the dealii &quot;symmetrize&quot; function</div><div class="line">dealii::Tensor&lt;2, dim, dealii::VectorizedArray&lt;double&gt; &gt; E;</div><div class="line">E = symmetrize(Dux);</div><div class="line"></div><div class="line">// Compute stress tensor (which is equal to the residual, Rux)</div><div class="line">if (n_dependent_stiffness == true){</div><div class="line">    dealii::Tensor&lt;2, CIJ_tensor_size, dealii::VectorizedArray&lt;double&gt; &gt; CIJ_combined;</div><div class="line">    CIJ_combined = CIJ_Mg*(constV(1.0)-h1V-h2V-h3V) + CIJ_Beta*(h1V+h2V+h3V);</div><div class="line"></div><div class="line">    computeStress&lt;dim&gt;(CIJ_combined, E, eqx_Du);</div><div class="line">}</div><div class="line">else{</div><div class="line">    computeStress&lt;dim&gt;(CIJ_Mg, E, eqx_Du);</div><div class="line">}</div><div class="line"></div><div class="line">// --- Submitting the terms for the governing equations ---</div><div class="line"></div><div class="line">variable_list.set_vector_gradient_term_LHS(4,eqx_Du);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Like the functions for the RHS, equationLHS takes variables_list and q_point_loc as inputs. However, because only one TIME_INDEPENDENT equation is solved at a time, the output are the terms for a single governing equation. As in explicitEquationRHS and nonExplicitEquationRHS, the model variable values and derivatives are given convenient names at the start of the file. The equationLHS function has a new option for getting variable values and derivatives, here one can access the change in the value of one of the variables or its derivatives. The function name is <code>get_change_in_vector_gradient</code> above. The other options are <code>get_change_in_scalar_value</code>, <code>get_change_in_scalar_gradient</code>, <code>get_change_in_scalar_hessian</code>, <code>get_change_in_vector_value</code>, and <code>get_change_in_vector_hessian</code>. Similar to the RHS functions, the value of eqx_Du is set and then used to set the appropriate residual for variables_list (in this case the vector residual term for the fourth variable).</p>
<p>If multiple TIME_INDEPENDENT equations need to be solved, you will need to use conditional statements to calculate the proper residual depending on the elliptic equation being solved. The index of the field being solved can be accessed using the <code>this-$&gt;$currentFieldIndex</code> statement.</p>
<h2>ICs_and_BCs.cc</h2>
<p>The file ''ICs_and_BCs.cc'' contains the initial conditions for the primary variables as well as the expressions for non-uniform Dirichlet boundary conditions, if present. The file contains two functions: setInitialCondition and setNonUniformDirichletBCs.</p>
<h3>setInitialCondition</h3>
<p>Here's a look at the setInitialCondition function for the coupled Allen-Cahn/Cahn-Hilliard example application: </p><div class="fragment"><div class="line">template &lt;int dim, int degree&gt;</div><div class="line">void customPDE&lt;dim,degree&gt;::setInitialCondition(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, double &amp; scalar_IC, dealii::Vector&lt;double&gt; &amp; vector_IC){</div><div class="line">    // ---------------------------------------------------------------------</div><div class="line">    // ENTER THE INITIAL CONDITIONS HERE</div><div class="line">    // ---------------------------------------------------------------------</div><div class="line">    // Enter the function describing conditions for the fields at point &quot;p&quot;.</div><div class="line">    // Use &quot;if&quot; statements to set the initial condition for each variable</div><div class="line">    // according to its variable index</div><div class="line">      // The initial condition is two circles/spheres defined</div><div class="line">      // by a hyperbolic tangent function. The center of each circle/sphere is</div><div class="line">      // given by &quot;center&quot; and its radius is given by &quot;rad&quot;.</div><div class="line"></div><div class="line">      double dist;</div><div class="line">      scalar_IC = 0;</div><div class="line"></div><div class="line">      if (index == 0){</div><div class="line">          scalar_IC = matrix_concentration;</div><div class="line">      }</div><div class="line"></div><div class="line">      dist = 0.0;</div><div class="line">      for (unsigned int dir = 0; dir &lt; dim; dir++){</div><div class="line">          dist += (p[dir]-center1[dir])*(p[dir]-center1[dir]);</div><div class="line">      }</div><div class="line">      dist = std::sqrt(dist);</div><div class="line"></div><div class="line">      // Initial condition for the concentration field</div><div class="line">      if (index == 0){</div><div class="line">          scalar_IC += 0.5*(0.125)*(1.0-std::tanh((dist-radius1)/(1.0)));</div><div class="line">      }</div><div class="line">      else {</div><div class="line">          scalar_IC += 0.5*(1.0-std::tanh((dist-radius1)/(1.0)));</div><div class="line">      }</div><div class="line"></div><div class="line">      dist = 0.0;</div><div class="line">      for (unsigned int dir = 0; dir &lt; dim; dir++){</div><div class="line">          dist += (p[dir]-center2[dir])*(p[dir]-center2[dir]);</div><div class="line">      }</div><div class="line">      dist = std::sqrt(dist);</div><div class="line"></div><div class="line">      // Initial condition for the concentration field</div><div class="line">      if (index == 0){</div><div class="line">          scalar_IC += 0.5*(0.125)*(1.0-std::tanh((dist-radius2)/(1.0)));</div><div class="line">      }</div><div class="line">      else {</div><div class="line">          scalar_IC += 0.5*(1.0-std::tanh((dist-radius2)/(1.0)));</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">      // --------------------------------------------------------------------------</div><div class="line">}</div></div><!-- fragment --><p>In this function, the variable <code>scalarIC</code> should be set to the desired initial condition. The (x,y,z) coordinates can be accessed by the <code>p</code> variable, with indices zero through 2. For example, if you wanted to initialize a field to \(5xy\), you would enter:</p>
<div class="fragment"><div class="line">scalarIC = 5.0 * p[0] * p[1];</div></div><!-- fragment --><p>The initial conditions given above are a bit more complicated. They set the initial conditions for two circular (spherical in 3D) particles. The initial condition for different variables is set using conditional statements and the <code>index</code> variable. The <code>index</code> variable refers to the variable index from the top of the ''equations.cc''. This example uses conditional statements to set the initial conditions differently for the concentration (<code>index=0</code>) and the structural order parameter (<code>index=1</code>). The initial conditions for both fields are calculated using hyperbolic tangent functions that make use of the distance between the centers of the particles and the point <code>p</code>.</p>
<p>The initial conditions for vector fields are set using <code>vector_IC</code>. As an example, here is a section of the setInitialCondition function in the MgNd_precipitate_single_Bppp app: </p><div class="fragment"><div class="line">else {</div><div class="line">          for (unsigned int d=0; d&lt;dim; d++){</div><div class="line">              vector_IC(d) = 0.0;</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>The model constants defined in parameters.prm can be used in the initial condition function (or boundary condition function), just as in the equation functions in equations.cc.</p>
<h3>setNonUniformDirichletBCs</h3>
<p>This function is needed when one or more boundaries are set to NON_UNIFORM_DIRICHLET. These functions are very similar to the initial condition functions above, the user sets an expression for <code>scalar_BC</code> or <code>vector_BC</code> at point <code>p</code>. Once again, the variable <code>index</code> is used to differentiate between variables based on their index from the top of the 'equations.cc' file. For Dirichlet boundary conditions that vary in time, the current time can be accessed via the variable <code>time</code>.</p>
<p>Currently, the one of the only two applications that use a non-uniform Dirichlet boundary condition is CHiMaD_benchmark6a (the other is CHiMaD_benchmark6b). Here is the setNonUniformDirichletBCs function from CHiMaD_benchmark6a: </p><div class="fragment"><div class="line">template &lt;int dim, int degree&gt;</div><div class="line">void customPDE&lt;dim,degree&gt;::setNonUniformDirichletBCs(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, const unsigned int direction, const double time, double &amp; scalar_BC, dealii::Vector&lt;double&gt; &amp; vector_BC)</div><div class="line">{</div><div class="line">    // --------------------------------------------------------------------------</div><div class="line">    // ENTER THE NON-UNIFORM DIRICHLET BOUNDARY CONDITIONS HERE</div><div class="line">    // --------------------------------------------------------------------------</div><div class="line">    // Enter the function describing conditions for the fields at point &quot;p&quot;.</div><div class="line">    // Use &quot;if&quot; statements to set the boundary condition for each variable</div><div class="line">    // according to its variable index. This function can be left blank if there</div><div class="line">    // are no non-uniform Dirichlet boundary conditions. For BCs that change in</div><div class="line">    // time, you can access the current time through the variable &quot;time&quot;. The</div><div class="line">    // boundary index can be accessed via the variable &quot;direction&quot;, which starts</div><div class="line">    // at zero and uses the same order as the BC specification in parameters.prm</div><div class="line">    // (i.e. left = 0, right = 1, bottom = 2, top = 3, front = 4, back = 5).</div><div class="line"></div><div class="line">    if (index == 2){</div><div class="line">        if (direction == 1){</div><div class="line">            double x=p[0];</div><div class="line">            double y=p[1];</div><div class="line">            scalar_BC=std::sin(y/7.0);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    // -------------------------------------------------------------------------</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h2>postprocess.cc</h2>
<p>Unlike the files discussed so far in this section, the postprocess.cc file is optional. This file allows users to specify fields other than the primary model variable to output. It also includes an option to integrate over a field variable (e.g. to check conservation of a field). In the example problems, this file is often used to calculate the total free energy of the system, which should be monotonically decreasing for most phase field problems. It also is convenient for calculating somewhat complicated expressions such as chemical potentials, stresses, and strains.</p>
<p>Note: Two restrictions are currently in place for the postprocessor. First, postprocessing variables can only be scalars, not vectors. Second, the postprocessor won't work if the primary model variable with index zero is a vector. (This is because postprocessor uses the mesh of the zeroth primary variable to calculate and output the postprocessed field.) These restrictions will be lifted in future versions of PRISMS-PF.</p>
<p>The file contains two functions: loadPostProcessorVariableAttributes and postProcessedFields.</p>
<h3>loadPostProcessorVariableAttributes</h3>
<p>Similar to the equations.cc file, postprocess.cc begins with a function called loadPostProcessorVariableAttributes, which sets the attributes of the postprocessing variables. Here is the loadPostProcessorVariableAttributes function from the coupledCahnHilliardAllenCahn application, where the postprocessed field is <code>f_tot</code>, the total free energy: </p><div class="fragment"><div class="line">void variableAttributeLoader::loadPostProcessorVariableAttributes(){</div><div class="line"></div><div class="line">    // Variable 0</div><div class="line">    set_variable_name               (0,&quot;f_tot&quot;);</div><div class="line">    set_variable_type               (0,SCALAR);</div><div class="line"></div><div class="line">    set_dependencies_value_term_RHS(0, &quot;c,n,grad(n)&quot;);</div><div class="line">    set_dependencies_gradient_term_RHS(0, &quot;&quot;);</div><div class="line"></div><div class="line">    set_output_integral             (0,true);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function  </th><th class="markdownTableHeadNone">Options  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_variable_name  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">var  </td><td class="markdownTableBodyNone">Sets the name of the variable.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">set_variable_type  </td><td class="markdownTableBodyNone">SCALAR  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">SCALAR  </td><td class="markdownTableBodyNone">Sets whether the variable is a scalar or a vector. Only SCALAR is currently allowed.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_dependencies_value_term_RHS  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by <code>grad</code> and then the variable name in parentheses. Second derivatives are referenced by <code>hess</code> and then the variable name in parentheses.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">set_dependencies_gradient_term_RHS  </td><td class="markdownTableBodyNone">String  </td><td class="markdownTableBodyNone">yes  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by <code>grad</code> and then the variable name in parentheses. Second derivatives are referenced by <code>hess</code> and then the variable name in parentheses.   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">set_output_integral  </td><td class="markdownTableBodyNone">Boolean  </td><td class="markdownTableBodyNone">no  </td><td class="markdownTableBodyNone">false  </td><td class="markdownTableBodyNone">Sets whether the integral of the variable should be calculated and written to a file named 'integratedFields.txt'.   </td></tr>
</table>
<h3>postProcessedFields</h3>
<p>The second function in the <a class="el" href="postprocess_8h.html">postprocess.cc</a> file is similar to the residual functions in equations.cc. The primary difference is that, while the primary model fields are read in from <code>variable_list</code>, the residuals are submitted to <code>pp_variable_list</code>. Otherwise, the structure is similar and expressions can be copied from one function to another.</p>
<p>Here is the postProcessedFields from the coupledCahnHilliardAllenCahn application: </p><div class="fragment"><div class="line">template &lt;int dim,int degree&gt;</div><div class="line">void customPDE&lt;dim,degree&gt;::postProcessedFields(const variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line">                variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; pp_variable_list,</div><div class="line">                                                const dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"></div><div class="line">// --- Getting the values and derivatives of the model variables ---</div><div class="line"></div><div class="line">//c</div><div class="line">scalarvalueType c = variable_list.get_scalar_value(0);</div><div class="line"></div><div class="line">//n</div><div class="line">scalarvalueType n = variable_list.get_scalar_value(1);</div><div class="line">scalargradType nx = variable_list.get_scalar_gradient(1);</div><div class="line"></div><div class="line">// --- Setting the expressions for the terms in the postprocessing expressions ---</div><div class="line"></div><div class="line">// Free energy for each phase and their first and second derivatives</div><div class="line">scalarvalueType fa = (-1.6704-4.776*c+5.1622*c*c-2.7375*c*c*c+1.3687*c*c*c*c);</div><div class="line">scalarvalueType fb = (5.0*c*c-5.9746*c-1.5924);</div><div class="line"></div><div class="line">// Interpolation function and its derivative</div><div class="line">scalarvalueType h = (10.0*n*n*n-15.0*n*n*n*n+6.0*n*n*n*n*n);</div><div class="line"></div><div class="line">// The homogenous free energy</div><div class="line">scalarvalueType f_chem = (constV(1.0)-h)*fa + h*fb;</div><div class="line"></div><div class="line">// The gradient free energy</div><div class="line">scalarvalueType f_grad = constV(0.5*Kn)*nx*nx;</div><div class="line"></div><div class="line">// The total free energy</div><div class="line">scalarvalueType f_tot;</div><div class="line">f_tot = f_chem + f_grad;</div><div class="line"></div><div class="line">// --- Submitting the terms for the postprocessing expressions ---</div><div class="line"></div><div class="line">pp_variable_list.set_scalar_value_term_RHS(0, f_tot);</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h2><a class="el" href="nucleation_8cc.html">nucleation.cc</a></h2>
<p>The <a class="el" href="nucleation_8cc.html">nucleation.cc</a> file is also an optional file that is only needed when explicit nucleation is needed for the application. It contains the function getNucleationProbability, which calculates the probability of nucleation in a given volume element <code>dV</code> at a particular point in space <code>p</code> at time <code>this-$&gt;$currentTime</code>. Please refer to Note 6 <a href="https://prisms-center.github.io/phaseField/doxygen/input_file.html">on the input file page</a> for a description of the nucleation model in PRISMS-PF.</p>
<p>The values of the primary field variables can be accessed through the <code>variable_value</code> input, using the variable index from equations.cc. Only variables where set_need_value_nucleation was set to true in the loadVariableAttributes function in equations.cc can be accessed.</p>
<p>Here is getNucleationProbability from the nucleationModel application: </p><div class="fragment"><div class="line">template &lt;int dim, int degree&gt;</div><div class="line">double customPDE&lt;dim,degree&gt;::getNucleationProbability(variableValueContainer variable_value, double dV, dealii::Point&lt;dim&gt; p, unsigned int variable_index) const</div><div class="line">{</div><div class="line">    //Supersaturation factor</div><div class="line">    double ssf;</div><div class="line">    if (dim ==2) ssf=variable_value(0)-calmin;</div><div class="line">    if (dim ==3) ssf=(variable_value(0)-calmin)*(variable_value(0)-calmin);</div><div class="line">    // Calculate the nucleation rate</div><div class="line">    double J=k1*exp(-k2/(std::max(ssf,1.0e-6)))*exp(-tau/(this-&gt;currentTime));</div><div class="line">    double retProb=1.0-exp(-J*userInputs.dtValue*((double)userInputs.steps_between_nucleation_attempts)*dV);</div><div class="line">    return retProb;</div><div class="line">}</div></div><!-- fragment --><h2>customPDE.h</h2>
<p>The final file in each application folder that users often need to change is customPDE.h. This file contains the declarations for all of the functions and variables specific to the application. In C++ terminology, it is the declaration for the customPDE class, which is a subclass of <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a>. For most users, the relevant section is labeled as ''Model constants specific to this subclass'', which is where the model constants from parameters.prm are extracted from the <code>userInputs</code> object. There is a separate function to extract constants of each type. These are:</p>
<ul>
<li>get_model_constant_double</li>
<li>get_model_constant_int</li>
<li>get_model_constant_bool</li>
<li>get_model_constant_rank_1_tensor</li>
<li>get_model_constant_rank_2_tensor</li>
<li>get_model_constant_elasticity_tensor</li>
</ul>
<p>Each of these take the variable name from parameters.prm as an input and output the appropriate type.</p>
<p>Here is customPDE.h from the preciptiateEvolution application, where all of the different types of constants are used: </p><div class="fragment"><div class="line">#include &quot;../../include/matrixFreePDE.h&quot;</div><div class="line"></div><div class="line">template &lt;int dim, int degree&gt;</div><div class="line">class customPDE: public MatrixFreePDE&lt;dim,degree&gt;</div><div class="line">{</div><div class="line">public:</div><div class="line">    customPDE(userInputParameters&lt;dim&gt; _userInputs): MatrixFreePDE&lt;dim,degree&gt;(_userInputs) , userInputs(_userInputs) {};</div><div class="line">    // Function to set the initial conditions (in ICs_and_BCs.cc)</div><div class="line">    void setInitialCondition(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, double &amp; scalar_IC, dealii::Vector&lt;double&gt; &amp; vector_IC);</div><div class="line"></div><div class="line">    // Function to set the non-uniform Dirichlet boundary conditions (in ICs_and_BCs.cc)</div><div class="line">    void setNonUniformDirichletBCs(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, const unsigned int direction, const double time, double &amp; scalar_BC, dealii::Vector&lt;double&gt; &amp; vector_BC);</div><div class="line"></div><div class="line">    private:</div><div class="line">    #include &quot;../../include/typeDefs.h&quot;</div><div class="line"></div><div class="line">    const userInputParameters&lt;dim&gt; userInputs;</div><div class="line"></div><div class="line">    // Function to set the RHS of the governing equations for explicit time dependent equations (in equations.cc)</div><div class="line">    void explicitEquationRHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line">                     dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line"></div><div class="line">    // Function to set the RHS of the governing equations for all other equations (in equations.cc)</div><div class="line">    void nonExplicitEquationRHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line">                     dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line"></div><div class="line">    // Function to set the LHS of the governing equations (in equations.cc)</div><div class="line">    void equationLHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line">                     dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line"></div><div class="line">    // Function to set postprocessing expressions (in postprocess.cc)</div><div class="line">    #ifdef POSTPROCESS_FILE_EXISTS</div><div class="line">    void postProcessedFields(const variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line">                    variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; pp_variable_list,</div><div class="line">                    const dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line">    #endif</div><div class="line"></div><div class="line">    // Function to set the nucleation probability (in nucleation.cc)</div><div class="line">    #ifdef NUCLEATION_FILE_EXISTS</div><div class="line">    double getNucleationProbability(variableValueContainer variable_value, double dV) const;</div><div class="line">    #endif</div><div class="line"></div><div class="line">    // ================================================================</div><div class="line">    // Methods specific to this subclass</div><div class="line">    // ================================================================</div><div class="line"></div><div class="line"></div><div class="line">    // ================================================================</div><div class="line">    // Model constants specific to this subclass</div><div class="line">    // ================================================================</div><div class="line"></div><div class="line">    double McV = userInputs.get_model_constant_double(&quot;McV&quot;);</div><div class="line">    double Mn1V = userInputs.get_model_constant_double(&quot;Mn1V&quot;);</div><div class="line">    double Mn2V = userInputs.get_model_constant_double(&quot;Mn2V&quot;);</div><div class="line">    double Mn3V = userInputs.get_model_constant_double(&quot;Mn3V&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; Kn1 = userInputs.get_model_constant_rank_2_tensor(&quot;Kn1&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; Kn2 = userInputs.get_model_constant_rank_2_tensor(&quot;Kn2&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; Kn3 = userInputs.get_model_constant_rank_2_tensor(&quot;Kn3&quot;);</div><div class="line">    bool n_dependent_stiffness = userInputs.get_model_constant_bool(&quot;n_dependent_stiffness&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; sfts_linear1 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_linear1&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; sfts_const1 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_const1&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; sfts_linear2 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_linear2&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; sfts_const2 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_const2&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; sfts_linear3 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_linear3&quot;);</div><div class="line">    dealii::Tensor&lt;2,dim&gt; sfts_const3 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_const3&quot;);</div><div class="line">    double A4 = userInputs.get_model_constant_double(&quot;A4&quot;);</div><div class="line">    double A3 = userInputs.get_model_constant_double(&quot;A3&quot;);</div><div class="line">    double A2 = userInputs.get_model_constant_double(&quot;A2&quot;);</div><div class="line">    double A1 = userInputs.get_model_constant_double(&quot;A1&quot;);</div><div class="line">    double A0 = userInputs.get_model_constant_double(&quot;A0&quot;);</div><div class="line">    double B2 = userInputs.get_model_constant_double(&quot;B2&quot;);</div><div class="line">    double B1 = userInputs.get_model_constant_double(&quot;B1&quot;);</div><div class="line">    double B0 = userInputs.get_model_constant_double(&quot;B0&quot;);</div><div class="line"></div><div class="line">    const static unsigned int CIJ_tensor_size =2*dim-1+dim/3;</div><div class="line">    dealii::Tensor&lt;2,CIJ_tensor_size&gt; CIJ_Mg = userInputs.get_model_constant_elasticity_tensor(&quot;CIJ_Mg&quot;);</div><div class="line">    dealii::Tensor&lt;2,CIJ_tensor_size&gt; CIJ_Beta = userInputs.get_model_constant_elasticity_tensor(&quot;CIJ_Beta&quot;);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // ================================================================</div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>This file can also be used to declare new member functions for the application. One example of this is the seedNucleus function in the nucleationModel application.</p>
<p>Furthermore, for advanced users, the customPDE class can be used to override <a class="el" href="class_matrix_free_p_d_e.html">MatrixFreePDE</a> functions from the core PRISMS-PF library. One example of this is in the CHiMaD_benchmark6b application, where the makeTriangulation function is overridden to create a non-square mesh.</p>
<h2><a class="el" href="main_8cc.html">main.cc</a></h2>
<p>The final C++ file in the application directory is the <a class="el" href="main_8cc.html">main.cc</a> file. This file controls the overall flow of the code and is unlikely to be modified by most users. For all of the example applications, <a class="el" href="main_8cc.html">main.cc</a> is identical. One situation where a user may want to modify '<a class="el" href="main_8cc.html">main.cc</a>' is if they wanted to run several simulations with different parameter sets for one execution of the code. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PRISMS-PF: /Users/stephendewitt/Documents/workspace/PRISMS_workspace/prismspf-manual/user_manual/app_files/app_files.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML#http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="my_navtree.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_pic.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PRISMS-PF
   &#160;<span id="projectnumber">v2.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('app__files_8md.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/Users/stephendewitt/Documents/workspace/PRISMS_workspace/prismspf-manual/user_manual/app_files/app_files.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="app__files_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Other App Files {#app_files}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;This section details the files that define each application. The norm is that substantial modifications to these files consistute a new application (in contrast to simply making changes to the input file (&#39;parameters.in&#39;). Modifying these files may require some knowledge of C++.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;A very brief description of the purpose of each of these files is below, an in-depth discussion can be found in the following subsections:</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;- equations.cc: Specifies the attributes of the model variables and the model&#39;s residual equations</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;- ICs\_and\_BCs.cc: Specifies the initial conditions for each variable (unless the initial condition is read from file) and non-uniform Dirichlet boundary conditions, if applicable.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;- postprocess.cc: Specifies variable other than the primary model variables to output, as well as the expressions to derive these variables.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;- nucleation.cc: Contains the function that determines the probability density of nucleation.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;- customPDE.h: Contains the prototypes of the functions for the application, also contains declarations of the model constants given in the input file.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;- main.cc: Main C++ function that controls the flow of the simulation. Identical for all the example applications and it is unlikely that users will need to modify it.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;In all of these files, the user can access user inputs from parameters.in via the userInputs object (e.g. the domain size, the time step size). See the documentation entry for userInputParameters for a list of variable names inside &#39;&#39;userInputs&#39;&#39;.</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;## equations.cc</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;The file &#39;&#39;equations.cc&#39;&#39; contains a list of the variables in the model equations and their attributes as well as the residuals for the model equations. The file contains four functions: loadVariableAttributes, explicitEquationRHS, nonExplicitEquationRHS, and equationLHS.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;To modify the functions in this file, one needs to be familiar with the weak form of the governing equations. In PRISMS-PF, the governing equations are expressed in two terms. The first is the part of the integrand that is multiplied by the test function (marked by &#39;eq&#39; with the subscript of the variable in the example below). The second is the part of the integrand that multiplied by the gradient of the test function (marked by &#39;eqx&#39; with the subscript of the variable in the example below). For the coupled Cahn-Hilliard/Allen-Cahn system, the governing equations are</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;\f[</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;\int_{\Omega}   w  \eta^{n+1}  ~dV =\int_{\Omega}  w  \left( \underbrace{\eta^{n} - \Delta t M_{\eta}~ ((f_{\beta,c}^n-f_{\alpha,c}^n)H_{,\eta}^n)}_{eq_{\eta}} \right)+ \nabla w \cdot \underbrace{(- \Delta t M_{\eta}\kappa) \nabla \eta^{n}}_{eqx_{\eta}} ~dV</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;\f]</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;and</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;\f[</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;]$\int_{\Omega}   w  c^{n+1}  ~dV = \int_{\Omega}   w \underbrace{c^{n}}_{eq_c} +  \nabla w   \underbrace{(-\Delta t M_{c})~ [~(f_{\alpha,cc}^n(1-H^{n+1})+f_{\beta,cc}^n H^{n+1}) \nabla c + ~((f_{\beta,c}^n-f_{\alpha,c}^n)H^{n+1}_{,\eta} \nabla \eta) ] }_{eqx_{c}} ~dV</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;\f]</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;for the Allen-Cahn and Cahn-Hilliard equation, respectively. Each of the terms in the governing equation is marked with an underbrace. The terms multiplied by the test function are referred to as the value terms and the terms multiplied by the gradient of the test function are referred to as the gradient terms.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;### loadVariableAttributes</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;Here is the loadVariableAttributes function for the coupled Allen-Cahn/Cahn-Hilliard example application:</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;```</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;void variableAttributeLoader::loadVariableAttributes(){</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;   // Variable 0</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;   set_variable_name               (0,&quot;c&quot;);</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;   set_variable_type               (0,SCALAR);</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;   set_variable_equation_type      (0,EXPLICIT_TIME_DEPENDENT);</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    set_dependencies_value_term_RHS(0, &quot;c&quot;);</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    set_dependencies_gradient_term_RHS(0, &quot;n,grad(c)&quot;);</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    // Variable 1</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;   set_variable_name               (1,&quot;n&quot;);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;   set_variable_type               (1,SCALAR);</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;   set_variable_equation_type      (1,EXPLICIT_TIME_DEPENDENT);</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    set_dependencies_value_term_RHS(1, &quot;c,n&quot;);</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    set_dependencies_gradient_term_RHS(1, &quot;grad(n)&quot;);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;}</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;```</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;This function specifies the model variables and their attributes. In this case, the two model variables are the concentration, **c**, and the order parameter, **n**. Here, **c** is listed as the zeroth variable and **n** is listed as the first. For each variable, a series of attributes are set using a series of C++ function calls. The following table lists the functions and a description of the attributes they set:</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;| Function          | Options | Required | Default | Description |</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;| --------------|---------|----------|---------|----------------------------------------------------|</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;set_variable_name | [String] | no | var  | Sets the name of the variable. This name is used in &#39;parameters.in&#39; as well as during output.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;set_variable_type | SCALAR, VECTOR | no | SCALAR  | Sets whether the variable is a scalar or a vector.</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;set_variable_equation_type | EXPLICIT_TIME_DEPENDENT, AUXILIARY, TIME_INDEPENDENT | no | EXPLICIT_TIME_DEPENDENT  | Sets whether the governing equation for the variable is a time-dependent PDE (EXPLICIT_TIME_DEPENDENT), a time-independent PDE that does not require a linear solve (AUXILIARY) or a time independent PDE that does require a (non)linear solve (TIME_INDEPENDENT).</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;set_dependencies_value_term_RHS | String | yes | N/A| Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;set_dependencies_gradient_term_RHS | String | yes | N/A | Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;set_dependencies_value_term_LHS | String | no | [empty] | Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses. (Only needed for TIME_INDEPENDENT equations.)</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;set_dependencies_gradient_term_LHS | String | no | [empty] | Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses. (Only needed for TIME_INDEPENDENT equations.)</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;set_allowed_to_nucleate | Boolean | no | false | Sets whether the nucleation algorithms should be activated for this variable. (Only needed when nucleation is desired).</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;set_need_value_nucleation | Boolean | no | false | Sets whether the value of the variable is needed to calculate the nucleation probability in the &#39;nucleation.cc&#39; file. (Only needed when nucleation is desired).</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;Some of these function calls are not present in the &#39;equations.cc&#39; file for the coupledCahnHilliardAllenCahn application. Use of the LHS function calls can be found in the preciptiateEvolution application (among others) and use the nucleation function calls can be found the nucleationModel and nucleationModel_preferential applications.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;### explicitEquationRHS</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;The explicitEquationRHS function is where the terms in the RHS of the governing equations for EXPLICIT_TIME_DEPENDENT equations are entered. The terms in the RHS of other equations are entered into the nonExplicitEquationRHS function. Here is the explicitEquationRHS function from the coupled Allen-Cahn/Cahn-Hilliard example application:</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;```</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;void customPDE&lt;dim,degree&gt;::explicitEquationRHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;// --- Getting the values and derivatives of the model variables ---</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;//c</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;scalarvalueType c = variable_list.get_scalar_value(0);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;scalargradType cx = variable_list.get_scalar_gradient(0);</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;//n</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;scalarvalueType n = variable_list.get_scalar_value(1);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;scalargradType nx = variable_list.get_scalar_gradient(1);</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;// --- Setting the expressions for the terms in the governing equations ---</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;// Free energy for each phase and their first and second derivatives</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;scalarvalueType fa = (-1.6704-4.776*c+5.1622*c*c-2.7375*c*c*c+1.3687*c*c*c*c);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;scalarvalueType fac = (-4.776 + 10.3244*c - 8.2125*c*c + 5.4748*c*c*c);</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;scalarvalueType facc = (10.3244-16.425*c+16.4244*c*c);</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;scalarvalueType fb = (5.0*c*c-5.9746*c-1.5924);</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;scalarvalueType fbc = (10.0*c-5.9746);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;scalarvalueType fbcc = constV(10.0);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;// Interpolation function and its derivative</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;scalarvalueType h = (10.0*n*n*n-15.0*n*n*n*n+6.0*n*n*n*n*n);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;scalarvalueType hn = (30.0*n*n-60.0*n*n*n+30.0*n*n*n*n);</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;// Residual equations</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;scalargradType mux = ( cx*((1.0-h)*facc+h*fbcc) + nx*((fbc-fac)*hn) );</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;scalarvalueType eq_c = c;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;scalargradType eqx_c = (constV(-Mc*userInputs.dtValue)*mux);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;scalarvalueType eq_n = (n-constV(userInputs.dtValue*Mn)*(fb-fa)*hn);</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;scalargradType eqx_n = (constV(-userInputs.dtValue*Kn*Mn)*nx);</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;// --- Submitting the terms for the governing equations ---</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;// Terms for the equation to evolve the concentration</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;variable_list.set_scalar_value_term_RHS(0,eq_c);</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;variable_list.set_scalar_gradient_term_RHS(0,eqx_c);</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;// Terms for the equation to evolve the order parameter</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;variable_list.set_scalar_value_term_RHS(1,eq_n);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;variable_list.set_scalar_gradient_term_RHS(1,eqx_n);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;}</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;```</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;In this function the equation terms at a particular quadrature point are calculated. The inputs to this function are a list of the model variable values and derivatives, variable_list and a point giving access to (x,y,z) coordinates, q_point_loc. The equation terms are added to variable_list as the output. The first few lines of the function set more convenient names for the variables and their derivatives. By convention, the value of the variable is denoted by the variable name (c for the concentration and n for the structural order parameter in this case), the list of first derivatives is denoted by the variable name followed by an &#39;&#39;x&#39;&#39;, and second derivatives are denoted by the variable name followed by &#39;&#39;xx&#39;&#39;. Each variable in variable can be accessed by the index it was given in loadVariableAttributes. The variable value and the derivatives can be accessed through the get_scalar_value,  get_scalar_gradient, and get_scalar_hessian object members for scalar variables and the  get_vector_value,  get_vector_gradient, and get_vector_hessian functions. The data type for the value of a scalar variable is scalarvalueType (a scalar), the data type for the first derivatives of a scalar variable is scalargradType (a vector with a length equal to the number of dimensions), and the data type for the second derivatives of a scalar variable is scalarhessType (a matrix with a size equal to the number of dimensions by the number of dimensions). For vector variables, the data types are vectorvalueType (a vector with length equal to the number of dimensions), vectorgradType (a matrix with a size equal to the number of dimensions by the number of dimensions), and vectorgradType (a rank-three tensor with a size in each direction equal to the number of dimensions).</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;After the nicknames for the field variables are set, the equation terms are calculated (including some intermediate variables, such as the free energies and the interpolation functions in the example above). These use the same six data types discussed in the preceding paragraph. The model variables given in &#39;parameters.in&#39; can be used to define the residual terms.</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;Finally, the terms for the governing equations are submitted to variable_list, using the functions set_scalar_value_term_RHS, set_scalar_gradient_term_RHS, set_vector_value_term_RHS, and set_vector_gradient_term_RHS, once again referring the variables by their index.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;The nickname step can be skipped, if desired, although the code is generally more readable with nicknames (and the performance is in some cases better using the nicknames). An example without nicknames for the fields can be found in the grainGrowth application, where loops over the ten variables are easier to construct when not declaring all of the variables at once. One word of caution, though: calling set_scalar_value_term_RHS and set_scalar_gradient_term_RHS overwrites the value and gradient of the variable, respectively (and same for the variants for vectors). Thus, either the equation terms need to be cached and then set after all the equation terms have been calculated (as is done in the grainGrowth application) or the values and gradients need to be cached before setting the equation terms (as is done with the standard nicknaming approach).</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;#### A note on types</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;The deal.II library uses a data structure called a VectorizedArray to store the variable values and their derivatives. This data structured in optimized for modern vectorized processors, giving a substantial speedup in some cases. However, this data structure can complicate things slightly. One complicating factor is that VectorizedArrays can&#39;t always be added, subtracted, multiplied, or divided with more standard data types like doubles. For this reason, you will see the &#39;&#39;constV(argument)&#39;&#39; function scattered throughout the code. This function turns a non-VectorizedArray into a VectorizedArray. To be safe, you can always encase non-VectorizedArrays with &#39;&#39;constV()&#39;&#39; when they share an operation with a VectorizedArray. A second complication is that not all of the standard mathematical operations are available for VectorizedArrays. The basic trigonometric functions are available, as are exponentials and square roots. However, hyperbolic tangents are not. If needed, they must be constructed from exponents (or by iterating through the VectorizedArray, see below). A third complication is that conditional statements involving VectorizedArrays are not allowed. To perform a conditional statement, you must iterate through the VectorizedArray. To do still, construct a for loop where the maximum index is [variable name].n_array_elements. For examples of this, refer to the postprocessing file for the grainGrowth app or the seedNucleus function in &#39;equations.cc&#39; in the nucleationModel app. For more details on the deal.II implementation of VectorizedArrays (including a list of mathematical operations that are allowed), please visit [the relevant deal.II documentation page](https://www.dealii.org/8.4.0/doxygen/deal.II/classVectorizedArray.html).</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;### nonExplicitEquationRHS</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;The &#39;nonExplicitEquationRHS&#39; function is where the terms in the RHS of the governing equations for AUXILIARY and TIME_INDEPENDENT equations are entered. The terms in the RHS of EXPLICIT_TIME_DEPENDENT equations are entered into the explicitEquationRHS function. The structure and use is otherwise identical to explicitEquationRHS. Examples of apps where this function is used include cahnHilliard (for an AUXILIARY equation) and MgNd_precipitate_single_Bppp (for AUXILIARY and TIME_INDEPENDENT equations).</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;### equationLHS</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;In the coupledCahnHilliardAllenCahn app, the equationLHS function is empty because it is only needed for TIME_INDEPENDENT PDEs (or more specifically, when a non-trivial matrix inversion needs to be performed). Here we go through the equationLHS function from the precipitateEvolution application, where the equation for mechanical equilibrium is TIME_INDEPENDENT.</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;From the formulation file in the precipitateEvolution application, the governing equation for the mechanical displacement is:</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;\f[</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;R(u) = \int_{\Omega}   \nabla w :  C(\eta_1, \eta_2, \eta_3) : \left( \epsilon - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = 0</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;\f]</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;In PRISMS-PF, matrix inversion problems are always written as Newton&#39;s method iterations. For linear equations, like the one above, the solution is reached in a single Newton step. The reason for this approach is two-fold. First, it provides an identical user interface for linear and nonlinear problems. Second, it enables the efficient handling of constraints for when inhomogeneous Dirichlet boundary conditions are used.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;To write the above equations in terms of a Newton iteration, the solution, \f$u\f$, can be written as the sum of an initial guess, \f$u_0\f$, and an update, \f$\Delta u\f$:</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;\f[</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;R(u) = R(u_0 + \Delta u) = R(u_0) +  \int_{\Omega} \left. \frac{\delta R(u)}{\delta u}\right|_{u=u_0} \Delta u ~dV = 0</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;\f]</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;In this case, the equation is linear and the variation derivative is trivial:</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;\f[</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;R(u_0 + \Delta u) =  \int_{\Omega}   \nabla w :  C(\eta_1, \eta_2, \eta_3) : \left( \epsilon(u_0 + \Delta u) - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = \int_{\Omega}   \nabla w :  C(\eta_1, \eta_2, \eta_3) : \left( \epsilon(u_0) + \epsilon(\Delta u) - \epsilon^0(c,\eta_1, \eta_2, \eta_3)\right) ~dV = 0</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;\f]</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;Rearranging yields:</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;\f[</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;\int_{\Omega} \nabla w : \underbrace{C : \nabla (\epsilon(\Delta u))}_{eqx_{u}^{LHS}} dV = -\int_{\Omega}   \nabla w : \underbrace{C :(\epsilon(u_0)-\epsilon^0)}_{eqx_{u}^{RHS}} ~dV</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;\f]</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;The above values of \f$eqx_{u}^{LHS}\f$ and \f$eqx_{u}^{RHS}\f$ are used to define the residuals in the equations.h file. A similar process can be undertaken for other TIME_INDEPENDENT problems.</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;Here is the &#39;equationLHS&#39; function from the precipitateEvolution example application:</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;```</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;void customPDE&lt;dim,degree&gt;::equationLHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;       dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;// --- Getting the values and derivatives of the model variables ---</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;//n1</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;scalarvalueType n1 = variable_list.get_scalar_value(1);</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;//n2</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;scalarvalueType n2 = variable_list.get_scalar_value(2);</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;//n3</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;scalarvalueType n3 = variable_list.get_scalar_value(3);</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;//u</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;vectorgradType Dux = variable_list.get_change_in_vector_gradient(4);</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;// --- Setting the expressions for the terms in the governing equations ---</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;vectorgradType eqx_Du;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;// Interpolation functions</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;scalarvalueType h1V = (10.0*n1*n1*n1-15.0*n1*n1*n1*n1+6.0*n1*n1*n1*n1*n1);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;scalarvalueType h2V = (10.0*n2*n2*n2-15.0*n2*n2*n2*n2+6.0*n2*n2*n2*n2*n2);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;scalarvalueType h3V = (10.0*n3*n3*n3-15.0*n3*n3*n3*n3+6.0*n3*n3*n3*n3*n3);</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;// Take advantage of E being simply 0.5*(ux + transpose(ux)) and use the dealii &quot;symmetrize&quot; function</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;dealii::Tensor&lt;2, dim, dealii::VectorizedArray&lt;double&gt; &gt; E;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;E = symmetrize(Dux);</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;// Compute stress tensor (which is equal to the residual, Rux)</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;if (n_dependent_stiffness == true){</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;   dealii::Tensor&lt;2, CIJ_tensor_size, dealii::VectorizedArray&lt;double&gt; &gt; CIJ_combined;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;   CIJ_combined = CIJ_Mg*(constV(1.0)-h1V-h2V-h3V) + CIJ_Beta*(h1V+h2V+h3V);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;   computeStress&lt;dim&gt;(CIJ_combined, E, eqx_Du);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;}</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;else{</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;   computeStress&lt;dim&gt;(CIJ_Mg, E, eqx_Du);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;}</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;// --- Submitting the terms for the governing equations ---</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;variable_list.set_vector_gradient_term_LHS(4,eqx_Du);</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;}</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;```</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;Like the functions for the RHS, equationLHS takes variables_list and q_point_loc as inputs. However, because only one TIME_INDEPENDENT equation is solved at a time, the output are the terms for a single governing equation. As in explicitEquationRHS and nonExplicitEquationRHS, the model variable values and derivatives are given convenient names at the start of the file. The equationLHS function has a new option for getting variable values and derivatives, here one can access the change in the value of one of the variables or its derivatives. The function name is ```get_change_in_vector_gradient``` above. The other options are ```get_change_in_scalar_value```, ```get_change_in_scalar_gradient```, ```get_change_in_scalar_hessian```, ```get_change_in_vector_value```, and ```get_change_in_vector_hessian```.  Similar to the RHS functions, the value of eqx_Du is set and then used to set the appropriate residual for variables_list (in this case the vector residual term for the fourth variable).</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;If multiple TIME_INDEPENDENT equations need to be solved, you will need to use conditional statements to calculate the proper residual depending on the elliptic equation being solved. The index of the field being solved can be accessed using the ```this-$&gt;$currentFieldIndex``` statement.</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;## ICs_and_BCs.cc</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;The file &#39;&#39;ICs_and_BCs.cc&#39;&#39; contains the initial conditions for the primary variables as well as the expressions for non-uniform Dirichlet boundary conditions, if present. The file contains two functions: setInitialCondition and setNonUniformDirichletBCs.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;### setInitialCondition</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;Here&#39;s a look at the setInitialCondition function for the coupled Allen-Cahn/Cahn-Hilliard example application:</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;```</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;void customPDE&lt;dim,degree&gt;::setInitialCondition(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, double &amp; scalar_IC, dealii::Vector&lt;double&gt; &amp; vector_IC){</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    // ---------------------------------------------------------------------</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    // ENTER THE INITIAL CONDITIONS HERE</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    // ---------------------------------------------------------------------</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    // Enter the function describing conditions for the fields at point &quot;p&quot;.</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    // Use &quot;if&quot; statements to set the initial condition for each variable</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    // according to its variable index</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;     // The initial condition is two circles/spheres defined</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;     // by a hyperbolic tangent function. The center of each circle/sphere is</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;     // given by &quot;center&quot; and its radius is given by &quot;rad&quot;.</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      double dist;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;     scalar_IC = 0;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;     if (index == 0){</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;         scalar_IC = matrix_concentration;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;     }</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      dist = 0.0;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      for (unsigned int dir = 0; dir &lt; dim; dir++){</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;          dist += (p[dir]-center1[dir])*(p[dir]-center1[dir]);</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      }</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      dist = std::sqrt(dist);</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      // Initial condition for the concentration field</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      if (index == 0){</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;          scalar_IC += 0.5*(0.125)*(1.0-std::tanh((dist-radius1)/(1.0)));</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      }</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      else {</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;          scalar_IC += 0.5*(1.0-std::tanh((dist-radius1)/(1.0)));</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      }</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      dist = 0.0;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      for (unsigned int dir = 0; dir &lt; dim; dir++){</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;          dist += (p[dir]-center2[dir])*(p[dir]-center2[dir]);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;      }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;      dist = std::sqrt(dist);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;      // Initial condition for the concentration field</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      if (index == 0){</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;          scalar_IC += 0.5*(0.125)*(1.0-std::tanh((dist-radius2)/(1.0)));</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;      }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;      else {</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;          scalar_IC += 0.5*(1.0-std::tanh((dist-radius2)/(1.0)));</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;      }</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;     // --------------------------------------------------------------------------</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;}</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;```</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;In this function, the variable ```scalarIC``` should be set to the desired initial condition. The (x,y,z) coordinates can be accessed by the ```p``` variable, with indices zero through 2. For example, if you wanted to initialize a field to \f$5xy\f$, you would enter:</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;```</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;scalarIC = 5.0 * p[0] * p[1];</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;```</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;The initial conditions given above are a bit more complicated. They set the initial conditions for two circular (spherical in 3D) particles. The initial condition for different variables is set using conditional statements and the ```index``` variable. The ```index``` variable refers to the variable index from the top of the &#39;&#39;equations.h&#39;&#39;. This example uses conditional statements to set the initial conditions differently for the concentration (```index=0```) and the structural order parameter  (```index=1```). The initial conditions for both fields are calculated using hyperbolic tangent functions that make use of the distance between the centers of the particles and the point ```p```.</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;The initial conditions for vector fields are set using ```vector_IC```. As an example, here is a section of the setInitialCondition function in the MgNd_precipitate_single_Bppp app:</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;```</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;else {</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;          for (unsigned int d=0; d&lt;dim; d++){</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;              vector_IC(d) = 0.0;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;          }</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      }</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;```</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;The model constants defined in parameters.in can be used in the initial condition function (or boundary condition function), just as in the equation functions in equations.cc.</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;### setNonUniformDirichletBCs</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;This function is needed when one or more boundaries are set to NON_UNIFORM_DIRICHLET. These functions are very similar to the initial condition functions above, the user sets an expression for ```scalar_BC``` or ```vector_BC``` at point ```p```. Once again, the variable ```index``` is used to differentiate between variables based on their index from the top of the &#39;equations.cc&#39; file. For Dirichlet boundary conditions that vary in time, the current time can be accessed via the variable ```time```.</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;Currently, the one of the only two applications that use a non-uniform Dirichlet boundary condition is CHiMaD_benchmark6a (the other is CHiMaD\_benchmark6b). Here is the setNonUniformDirichletBCs function from CHiMaD_benchmark6a:</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;```</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;void customPDE&lt;dim,degree&gt;::setNonUniformDirichletBCs(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, const unsigned int direction, const double time, double &amp; scalar_BC, dealii::Vector&lt;double&gt; &amp; vector_BC)</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;{</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    // --------------------------------------------------------------------------</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    // ENTER THE NON-UNIFORM DIRICHLET BOUNDARY CONDITIONS HERE</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    // --------------------------------------------------------------------------</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    // Enter the function describing conditions for the fields at point &quot;p&quot;.</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    // Use &quot;if&quot; statements to set the boundary condition for each variable</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    // according to its variable index. This function can be left blank if there</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    // are no non-uniform Dirichlet boundary conditions. For BCs that change in</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;    // time, you can access the current time through the variable &quot;time&quot;. The</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    // boundary index can be accessed via the variable &quot;direction&quot;, which starts</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;    // at zero and uses the same order as the BC specification in parameters.in</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    // (i.e. left = 0, right = 1, bottom = 2, top = 3, front = 4, back = 5).</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    if (index == 2){</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        if (direction == 1){</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;            double x=p[0];</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;            double y=p[1];</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;            scalar_BC=std::sin(y/7.0);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        }</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;    }</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    // -------------------------------------------------------------------------</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;}</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;```</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;## postprocess.cc</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;Unlike the files discussed so far in this section, the postprocess.cc file is optional. This file allows users to specify fields other than the primary model variable to output. It also includes an option to integrate over a field variable (e.g. to check conservation of a field). In the example problems, this file is often used to calculate the total free energy of the system, which should be monotonically decreasing for most phase field problems. It also is convenient for calculating somewhat complicated expressions such as chemical potentials, stresses, and strains.</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;Note: Two restrictions are currently in place for the postprocessor. First, postprocessing variables can only be scalars, not vectors. Second, the postprocessor won&#39;t work if the primary model variable with index zero is a vector. (This is because postprocessor uses the mesh of the zeroth primary variable to calculate and output the postprocessed field.) These restrictions will be lifted in future versions of PRISMS-PF.</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;The file contains two functions: loadPostProcessorVariableAttributes and postProcessedFields.</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;### loadPostProcessorVariableAttributes</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;Similar to the equations.cc file, postprocess.cc begins with a function called loadPostProcessorVariableAttributes, which sets the attributes of the postprocessing variables. Here is the loadPostProcessorVariableAttributes function from the coupledCahnHilliardAllenCahn application, where the postprocessed field is ```f_tot```, the total free energy:</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;```</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;void variableAttributeLoader::loadPostProcessorVariableAttributes(){</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;   // Variable 0</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;   set_variable_name               (0,&quot;f_tot&quot;);</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;   set_variable_type               (0,SCALAR);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    set_dependencies_value_term_RHS(0, &quot;c,n,grad(n)&quot;);</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    set_dependencies_gradient_term_RHS(0, &quot;&quot;);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    set_output_integral            (0,true);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;}</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;```</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;| Function          | Options | Required | Default | Description |</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;| --------------|---------|----------|---------|----------------------------------------------------|</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;set_variable_name | String | no | var  | Sets the name of the variable.</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;set_variable_type | SCALAR | no | SCALAR  | Sets whether the variable is a scalar or a vector. Only SCALAR is currently allowed.</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;set_dependencies_value_term_RHS | String | yes | | Sets which variables and their derivatives are needed to calculate the value term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses.</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;set_dependencies_gradient_term_RHS | String | yes | | Sets which variables and their derivatives are needed to calculate the gradient term for the RHS. Variables are referenced by their names. First derivatives are referenced by ```grad``` and then the variable name in parentheses. Second derivatives are referenced by ```hess``` and then the variable name in parentheses.</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;set_output_integral | Boolean | no | false | Sets whether the integral of the variable should be calculated and written to a file named &#39;integratedFields.txt&#39;.</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;### postProcessedFields</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;The second function in the postprocess.h file is similar to the residual functions in equations.h. The primary difference is that, while the primary model fields are read in from ```variable_list```, the residuals are submitted to ```pp_variable_list```. Otherwise, the structure is similar and expressions can be copied from one function to another.</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;Here is the postProcessedFields from the coupledCahnHilliardAllenCahn application:</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;```</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;template &lt;int dim,int degree&gt;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;void customPDE&lt;dim,degree&gt;::postProcessedFields(const variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;               variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; pp_variable_list,</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;                                               const dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const {</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;// --- Getting the values and derivatives of the model variables ---</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;//c</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;scalarvalueType c = variable_list.get_scalar_value(0);</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;//n</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;scalarvalueType n = variable_list.get_scalar_value(1);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;scalargradType nx = variable_list.get_scalar_gradient(1);</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;// --- Setting the expressions for the terms in the postprocessing expressions ---</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;// Free energy for each phase and their first and second derivatives</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;scalarvalueType fa = (-1.6704-4.776*c+5.1622*c*c-2.7375*c*c*c+1.3687*c*c*c*c);</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;scalarvalueType fb = (5.0*c*c-5.9746*c-1.5924);</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;// Interpolation function and its derivative</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;scalarvalueType h = (10.0*n*n*n-15.0*n*n*n*n+6.0*n*n*n*n*n);</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;// The homogenous free energy</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;scalarvalueType f_chem = (constV(1.0)-h)*fa + h*fb;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;// The gradient free energy</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;scalarvalueType f_grad = constV(0.5*Kn)*nx*nx;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;// The total free energy</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;scalarvalueType f_tot;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;f_tot = f_chem + f_grad;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;// --- Submitting the terms for the postprocessing expressions ---</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;pp_variable_list.set_scalar_value_term_RHS(0, f_tot);</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;}</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;```</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;## nucleation.cc</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;The nucleation.cc file is also an optional file that is only needed when explicit nucleation is needed for the application. It contains the function getNucleationProbability, which calculates the probability of nucleation in a given volume element ```dV``` at a particular point in space ```p``` at time ```this-$&gt;$currentTime```. Please refer to Note 6 [on the input file page ](https://prisms-center.github.io/phaseField/doxygen/input_file.html) for a description of the nucleation model in PRISMS-PF.</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;The values of the primary field variables can be accessed through the ```variable_value``` input, using the variable index from equations.cc. Only variables where set_need_value_nucleation was set to true in the loadVariableAttributes function in equations.cc can be accessed.</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;Here is getNucleationProbability from the nucleationModel application:</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;```</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;double customPDE&lt;dim,degree&gt;::getNucleationProbability(variableValueContainer variable_value, double dV, dealii::Point&lt;dim&gt; p, unsigned int variable_index) const</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;{</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;   //Supersaturation factor</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    double ssf;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    if (dim ==2) ssf=variable_value(0)-calmin;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    if (dim ==3) ssf=(variable_value(0)-calmin)*(variable_value(0)-calmin);</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;   // Calculate the nucleation rate</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;   double J=k1*exp(-k2/(std::max(ssf,1.0e-6)))*exp(-tau/(this-&gt;currentTime));</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;   double retProb=1.0-exp(-J*userInputs.dtValue*((double)userInputs.steps_between_nucleation_attempts)*dV);</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    return retProb;</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;}</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;```</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;## customPDE.h</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;The final file in each application folder that users often need to change is customPDE.h. This file contains the declarations for all of the functions and variables specific to the application. In C++ terminology, it is the declaration for the customPDE class, which is a subclass of MatrixFreePDE. For most users, the relevant section is labeled as &#39;&#39;Model constants specific to this subclass&#39;&#39;, which is where the model constants from parameters.in are extracted from the ```userInputs``` object. There is a separate function to extract constants of each type. These are:</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;- get\_model\_constant\_double</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;- get\_model\_constant\_int</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;- get\_model\_constant\_bool</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;- get\_model\_constant\_rank\_1\_tensor</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;- get\_model\_constant\_rank\_2\_tensor</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;- get\_model\_constant\_elasticity\_tensor</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;Each of these take the variable name from parameters.in as an input and output the appropriate type.</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;Here is customPDE.h from the preciptiateEvolution application, where all of the different types of constants are used:</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;```</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;#include &quot;../../include/matrixFreePDE.h&quot;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;template &lt;int dim, int degree&gt;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;class customPDE: public MatrixFreePDE&lt;dim,degree&gt;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;{</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;public:</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;   customPDE(userInputParameters&lt;dim&gt; _userInputs): MatrixFreePDE&lt;dim,degree&gt;(_userInputs) , userInputs(_userInputs) {};</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    // Function to set the initial conditions (in ICs_and_BCs.h)</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    void setInitialCondition(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, double &amp; scalar_IC, dealii::Vector&lt;double&gt; &amp; vector_IC);</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    // Function to set the non-uniform Dirichlet boundary conditions (in ICs_and_BCs.h)</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    void setNonUniformDirichletBCs(const dealii::Point&lt;dim&gt; &amp;p, const unsigned int index, const unsigned int direction, const double time, double &amp; scalar_BC, dealii::Vector&lt;double&gt; &amp; vector_BC);</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    private:</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    #include &quot;../../include/typeDefs.h&quot;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    const userInputParameters&lt;dim&gt; userInputs;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;    // Function to set the RHS of the governing equations for explicit time dependent equations (in equations.h)</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    void explicitEquationRHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                     dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    // Function to set the RHS of the governing equations for all other equations (in equations.h)</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    void nonExplicitEquationRHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                     dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    // Function to set the LHS of the governing equations (in equations.h)</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    void equationLHS(variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                     dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    // Function to set postprocessing expressions (in postprocess.h)</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    #ifdef POSTPROCESS_FILE_EXISTS</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    void postProcessedFields(const variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; variable_list,</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;                    variableContainer&lt;dim,degree,dealii::VectorizedArray&lt;double&gt; &gt; &amp; pp_variable_list,</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                    const dealii::Point&lt;dim, dealii::VectorizedArray&lt;double&gt; &gt; q_point_loc) const;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    #endif</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    // Function to set the nucleation probability (in nucleation.h)</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;    #ifdef NUCLEATION_FILE_EXISTS</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    double getNucleationProbability(variableValueContainer variable_value, double dV) const;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    #endif</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;   // ================================================================</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;   // Methods specific to this subclass</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;   // ================================================================</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;   // ================================================================</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;   // Model constants specific to this subclass</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;   // ================================================================</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;   double McV = userInputs.get_model_constant_double(&quot;McV&quot;);</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;   double Mn1V = userInputs.get_model_constant_double(&quot;Mn1V&quot;);</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;   double Mn2V = userInputs.get_model_constant_double(&quot;Mn2V&quot;);</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;   double Mn3V = userInputs.get_model_constant_double(&quot;Mn3V&quot;);</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;   dealii::Tensor&lt;2,dim&gt; Kn1 = userInputs.get_model_constant_rank_2_tensor(&quot;Kn1&quot;);</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;   dealii::Tensor&lt;2,dim&gt; Kn2 = userInputs.get_model_constant_rank_2_tensor(&quot;Kn2&quot;);</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;   dealii::Tensor&lt;2,dim&gt; Kn3 = userInputs.get_model_constant_rank_2_tensor(&quot;Kn3&quot;);</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;   bool n_dependent_stiffness = userInputs.get_model_constant_bool(&quot;n_dependent_stiffness&quot;);</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;   dealii::Tensor&lt;2,dim&gt; sfts_linear1 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_linear1&quot;);</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;   dealii::Tensor&lt;2,dim&gt; sfts_const1 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_const1&quot;);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;   dealii::Tensor&lt;2,dim&gt; sfts_linear2 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_linear2&quot;);</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;   dealii::Tensor&lt;2,dim&gt; sfts_const2 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_const2&quot;);</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;   dealii::Tensor&lt;2,dim&gt; sfts_linear3 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_linear3&quot;);</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;   dealii::Tensor&lt;2,dim&gt; sfts_const3 = userInputs.get_model_constant_rank_2_tensor(&quot;sfts_const3&quot;);</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;   double A4 = userInputs.get_model_constant_double(&quot;A4&quot;);</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;   double A3 = userInputs.get_model_constant_double(&quot;A3&quot;);</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;   double A2 = userInputs.get_model_constant_double(&quot;A2&quot;);</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;   double A1 = userInputs.get_model_constant_double(&quot;A1&quot;);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;   double A0 = userInputs.get_model_constant_double(&quot;A0&quot;);</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;   double B2 = userInputs.get_model_constant_double(&quot;B2&quot;);</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;   double B1 = userInputs.get_model_constant_double(&quot;B1&quot;);</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;   double B0 = userInputs.get_model_constant_double(&quot;B0&quot;);</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;   const static unsigned int CIJ_tensor_size =2*dim-1+dim/3;</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;   dealii::Tensor&lt;2,CIJ_tensor_size&gt; CIJ_Mg = userInputs.get_model_constant_elasticity_tensor(&quot;CIJ_Mg&quot;);</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;   dealii::Tensor&lt;2,CIJ_tensor_size&gt; CIJ_Beta = userInputs.get_model_constant_elasticity_tensor(&quot;CIJ_Beta&quot;);</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;   // ================================================================</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;};</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;```</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;This file can also be used to declare new member functions for the application. One example of this is the seedNucleus function in the nucleationModel application.</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;Furthermore, for advanced users, the customPDE class can be used to override MatrixFreePDE functions from the core PRISMS-PF library. One example of this is in the CHiMaD_benchmark6b application, where the makeTriangulation function is overridden to create a non-square mesh.</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;## main.cc</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;The final C++ file in the application directory is the main.cc file. This file controls the overall flow of the code and is unlikely to be modified by most users. For all of the example applications, main.cc is identical. One situation where a user may want to modify &#39;main.cc&#39; is if they wanted to run several simulations with different parameter sets for one execution of the code.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="app__files_8md.html">app_files.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
